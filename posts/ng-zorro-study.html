<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>蛋黄派碎冰冰</title><meta name="description" content="蛋黄派碎冰冰的博客"/><link rel="icon" href="/favicon.ico"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/e0545ffc3f78babf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e0545ffc3f78babf.css" data-n-g=""/><link rel="preload" href="/_next/static/css/4a0c5542377ce400.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4a0c5542377ce400.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fdc1f1e72b3c0540.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-e267bb9839e5051c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-fe85ddc63867fc19.js" defer=""></script><script src="/_next/static/chunks/347-34557e8e6f4e11a0.js" defer=""></script><script src="/_next/static/chunks/384-64a86c1d997b1133.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-f44b08a790a851f8.js" defer=""></script><script src="/_next/static/eQHzwepfXML6lMuZMdrtB/_buildManifest.js" defer=""></script><script src="/_next/static/eQHzwepfXML6lMuZMdrtB/_ssgManifest.js" defer=""></script><script src="/_next/static/eQHzwepfXML6lMuZMdrtB/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="Layout_container__CSAqU"><header class="Header_header__Z4YN5"><a href="/">蛋黄派碎冰冰</a><nav><ul><li><a href="/#posts">文章</a></li><li><a href="/about">关于</a></li></ul></nav></header><main><div class="Layout_banner__0qsJd"><h1>Ng-Zorro代码鉴赏</h1><p>Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。</p><div>2021-12-10 13:55:00</div></div><div class="content-container"><h1>Ng-Zorro代码鉴赏</h1>
<p>Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。</p>
<h2>目录</h2>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span>| 文件/文件名称 | 说明 | 
</span>| components | 组件文件夹，包含框架组件源码 |
<!-- -->| docs | 非组件文章文档，如国际化、全局配置等 |
<!-- -->| integration | 构建操作工具，搭配 travis 使用 |
<!-- -->| schematics | 自定义脚手架，ng g add ng-zorro-antd |
<!-- -->| scripts | 发布/调试脚本 |
<!-- -->| CODE_OF_CONDUCT.md | 贡献指南 |
<!-- -->| CHANGELOG.md | 发布日志 |
</code></pre>
<p>其中components/core 放了一些公共代码</p>
<p>关于和ant-design保持样式统一，他们使用了<a href="https://github.com/ng-zorro-bot">机器人</a>从ant-design同步样式代码。</p>
<h2>ONPUSH变更检测模式的使用</h2>
<p>angular中有两种检测模式，一种是CheckAlways，一种是CheckOnce，通过component装饰器的changeDetection字段来定义</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span>@Component({
</span>  changeDetection: ChangeDetectionStrategy.OnPush
<!-- -->})
<span>export </span><span style="color:#b48ead">declare</span><span> </span><span style="color:#b48ead">enum</span><span> ChangeDetectionStrategy {
</span>    /**
<span>     * Use the `CheckOnce` strategy, meaning that automatic change detection </span><span style="color:#d08770">is</span><span> deactivated
</span><span>     * </span><span style="color:#b48ead">until</span><span> reactivated </span><span style="color:#b48ead">by</span><span> setting the strategy </span><span style="color:#b48ead">to</span><span> `</span><span style="color:#b48ead">Default</span><span>` (`CheckAlways`).
</span>     * Change detection can still be explicitly invoked.
<span>     * This strategy applies </span><span style="color:#b48ead">to</span><span> all child directives </span><span style="color:#d08770">and</span><span> cannot be overridden.
</span>     */
<span>    OnPush = </span><span style="color:#d08770">0</span><span>,
</span>    /**
<span>     * Use the </span><span style="color:#b48ead">default</span><span> `CheckAlways` strategy, </span><span style="color:#b48ead">in</span><span> which change detection </span><span style="color:#d08770">is</span><span> automatic </span><span style="color:#b48ead">until</span><span>
</span>     * explicitly deactivated.
<!-- -->     */
<span>    </span><span style="color:#b48ead">Default</span><span> = </span><span style="color:#d08770">1</span><span>
</span>}
</code></pre>
<p>OnPush模式的使用:</p>
<p>由<a href="https://angular.cn/api/core/ChangeDetectorRef">ChangeDetectorRef</a>提供变更检测功能</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#b48ead">abstract</span><span> </span><span class="hljs-class" style="color:#b48ead">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#8fa1b3">ChangeDetectorRef</span><span class="hljs-class"> </span><span>{
</span><span>  </span><span style="color:#b48ead">abstract</span><span> markForCheck(): </span><span style="color:#d08770">void</span><span> </span><span style="color:#65737e">// 当视图使用 OnPush（checkOnce）变更检测策略时，把该视图显式标记为已更改，以便它再次进行检查。</span><span>
</span><span>  </span><span style="color:#b48ead">abstract</span><span> detach(): </span><span style="color:#d08770">void</span><span> </span><span style="color:#65737e">// 从变更检测树中分离开视图。 </span><span>
</span><span>  </span><span style="color:#b48ead">abstract</span><span> detectChanges(): </span><span style="color:#d08770">void</span><span> </span><span style="color:#65737e">// 检查该视图及其子视图。</span><span>
</span><span>  </span><span style="color:#b48ead">abstract</span><span> checkNoChanges(): </span><span style="color:#d08770">void</span><span> </span><span style="color:#65737e">// 检查变更检测器及其子检测器，如果检测到任何更改，则抛出异常。</span><span>
</span><span>  </span><span style="color:#b48ead">abstract</span><span> reattach(): </span><span style="color:#d08770">void</span><span> </span><span style="color:#65737e">// 把以前分离开的视图重新附加到变更检测树上。 视图会被默认附加到这棵树上。</span><span>
</span>}
</code></pre>
<p>使用示例：</p>
<p>zorro中这段代码出现过很多次，作用是当全局配置中对应当前组件的配置修改时，将视图标记为需检测。</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#d08770">this</span><span>.nzConfigService
</span>    .getConfigChangeEventForComponent(NZ_CONFIG_COMPONENT_NAME)
<span>    .pipe(takeUntil(</span><span style="color:#d08770">this</span><span>.destroy$))
</span><span>    .subscribe(</span><span class="hljs-function">() =&gt;</span><span> {
</span><span>    </span><span style="color:#d08770">this</span><span>.cdr.markForCheck();
</span>});
</code></pre>
<p>表单控件中，当writeVaule执行时（即将变化的数据写入视图时），标记为需检测。</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span>writeValue(value: </span><span style="color:#d08770">number</span><span>): </span><span style="color:#d08770">void</span><span> {
</span><span>    </span><span style="color:#d08770">this</span><span>.value = value;
</span><span>    </span><span style="color:#d08770">this</span><span>.setValue(value);
</span><span>    </span><span style="color:#d08770">this</span><span>.updateDisplayValue(value);
</span><span>    </span><span style="color:#d08770">this</span><span>.cdr.markForCheck();
</span>}
</code></pre>
<h2>使用<a href="https://angular.cn/api/core/NgZone">NgZone</a></h2>
<p>Zone 是跨异步任务而持久存在的执行上下文。</p>
<p>ngZone基于zone.js，是Angular变更检测的基础，Angular通过zone监听到了异步任务的执行过程，便于在异步任务执行时触发变更检测。</p>
<p>使用<code>ngZone.runOutsideAngular</code>让代码执行不触发新的变更检测，在调用<code>run</code>将这些任务重新进入Angular zone</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#d08770">this</span><span>.ngZone.runOutsideAngular(</span><span class="hljs-function">() =&gt;</span><span> {
</span><span>      fromEvent&lt;MouseEvent&gt;(</span><span style="color:#d08770">this</span><span>.elementRef.nativeElement, </span><span style="color:#a3be8c">&#x27;click&#x27;</span><span>)
</span><span>        .pipe(takeUntil(</span><span style="color:#d08770">this</span><span>.destroy$))
</span><span>        .subscribe(</span><span class="hljs-function" style="color:#d08770">event</span><span class="hljs-function"> =&gt;</span><span> {
</span><span>          </span><span style="color:#65737e">/** prevent label click triggered twice. **/</span><span>
</span>          event.stopPropagation();
<!-- -->          event.preventDefault();
<span>          </span><span style="color:#b48ead">if</span><span> (</span><span style="color:#d08770">this</span><span>.nzDisabled || </span><span style="color:#d08770">this</span><span>.isChecked) {
</span><span>            </span><span style="color:#b48ead">return</span><span>;
</span>          }
<span>          </span><span style="color:#d08770">this</span><span>.ngZone.run(</span><span class="hljs-function">() =&gt;</span><span> {
</span><span>            </span><span style="color:#b48ead">if</span><span> (</span><span style="color:#d08770">this</span><span>.nzRadioService) {
</span><span>              </span><span style="color:#d08770">this</span><span>.nzRadioService.select(</span><span style="color:#d08770">this</span><span>.nzValue);
</span>            }
<span>            </span><span style="color:#b48ead">if</span><span> (</span><span style="color:#d08770">this</span><span>.isNgModel) {
</span><span>              </span><span style="color:#d08770">this</span><span>.isChecked = </span><span style="color:#d08770">true</span><span>;
</span><span>              </span><span style="color:#d08770">this</span><span>.onChange(</span><span style="color:#d08770">true</span><span>);
</span>            }
<span>            </span><span style="color:#d08770">this</span><span>.cdr.markForCheck();
</span>          });
<!-- -->        });
<!-- -->    });
</code></pre>
<h2>对templateRef传参的处理</h2>
<p>Zorro的组件中很多支持<code>string | TemplateRef&lt;void&gt;</code>这种类型的传参，用于将字符串或模板植入组件视图。angular有一个<a href="https://angular.cn/api/common/NgTemplateOutlet">NgTemplateOutlet</a>指令，用于将templateRef插入视图，为了同时处理TemplateRef和string类型，zorro中封装了一个类似的指令<code>nzStringTemplateOutlet</code>。</p>
<p>核心代码为</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span class="hljs-function" style="color:#8fa1b3">constructor</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#b48ead">private</span><span class="hljs-function" style="color:#d08770"> viewContainer: ViewContainerRef, </span><span class="hljs-function" style="color:#b48ead">private</span><span class="hljs-function" style="color:#d08770"> templateRef: TemplateRef&lt;NzSafeAny&gt;</span><span class="hljs-function">)</span><span> {}
</span>
<span></span><span style="color:#b48ead">private</span><span> recreateView(): </span><span style="color:#d08770">void</span><span> {
</span><span>    </span><span style="color:#d08770">this</span><span>.viewContainer.clear();
</span><span>    </span><span style="color:#b48ead">const</span><span> isTemplateRef = </span><span style="color:#d08770">this</span><span>.nzStringTemplateOutlet </span><span style="color:#b48ead">instanceof</span><span> TemplateRef;
</span><span>    </span><span style="color:#b48ead">const</span><span> templateRef = (isTemplateRef ? </span><span style="color:#d08770">this</span><span>.nzStringTemplateOutlet : </span><span style="color:#d08770">this</span><span>.templateRef) </span><span style="color:#b48ead">as</span><span> NzSafeAny;
</span><span>    </span><span style="color:#d08770">this</span><span>.embeddedViewRef = </span><span style="color:#d08770">this</span><span>.viewContainer.createEmbeddedView(
</span>    templateRef,
<span>    isTemplateRef ? </span><span style="color:#d08770">this</span><span>.nzStringTemplateOutletContext : </span><span style="color:#d08770">this</span><span>.context
</span>    );
<!-- -->}
<!-- -->  
<span>ngOnChanges(changes: SimpleChanges): </span><span style="color:#d08770">void</span><span> {
</span><span>    </span><span style="color:#65737e">// ...</span><span>
</span><span>     </span><span style="color:#b48ead">if</span><span> (recreateView) {
</span><span>      </span><span style="color:#65737e">/** recreate view when context shape or outlet change **/</span><span>
</span><span>      </span><span style="color:#d08770">this</span><span>.recreateView();
</span><span>    } </span><span style="color:#b48ead">else</span><span> {
</span><span>    </span><span style="color:#65737e">// ...</span><span>
</span>	}
<!-- -->}
</code></pre>
<p>在很多个组件文件里都能看到他的使用，大概如下:</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span>&lt;ng-container *nzStringTemplateOutlet=</span><span style="color:#a3be8c">&quot;nzMessage&quot;</span><span>&gt;{{ nzMessage }}&lt;/ng-container&gt;
</span><span></span><span style="color:#d08770">@Input</span><span>() nzMessage: </span><span style="color:#d08770">string</span><span> | TemplateRef&lt;</span><span style="color:#d08770">void</span><span>&gt; | </span><span style="color:#d08770">null</span><span> = </span><span style="color:#d08770">null</span><span>;
</span></code></pre>
<p>指令是Angular中用于封装公共行为的强有力工具，它拥有了对模板的控制权，和组件一样拥有生命周期，但是使用起来更灵活。</p>
<h2>对装饰器的使用</h2>
<ol>
<li>
<p>属性装饰器</p>
<p>zorro中基本每一个组件都会看到@InputNumber、@InputBoolean这样的装饰器使用，用于对输入参数进行强制类型转换，避免因类型错误影响后面程序运行。</p>
<p>在typescript中声明一个工厂装饰器的思路大致如下：</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">name</span><span class="hljs-function"> (</span><span class="hljs-function">) </span><span>{
</span><span>    </span><span style="color:#b48ead">return</span><span> </span><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#d08770">target: IConfirmableDirective, propertyKey: </span><span class="hljs-function" style="color:#d08770">string</span><span class="hljs-function" style="color:#d08770">, descriptor: PropertyDescriptor</span><span class="hljs-function">) </span><span>{
</span><span>            </span><span style="color:#65737e">// TODO 对装饰对象的处理，并返回新的descriptor</span><span>
</span>    }
<!-- -->}
<!-- -->
</code></pre>
<p>zorro中定义了一个生产属性装饰器的函数，传入装饰器名称和对属性的处理函数，即可生成一个装饰器。</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">propDecoratorFactory</span><span class="hljs-function">&lt;</span><span class="hljs-function" style="color:#8fa1b3">T</span><span class="hljs-function">, </span><span class="hljs-function" style="color:#8fa1b3">D</span><span class="hljs-function">&gt;(</span><span class="hljs-function" style="color:#d08770">
</span><span class="hljs-function" style="color:#d08770">  name: </span><span class="hljs-function" style="color:#d08770">string</span><span class="hljs-function" style="color:#d08770">,
</span><span class="hljs-function" style="color:#d08770">  fallback: (v: T) =&gt; D
</span><span class="hljs-function" style="color:#d08770"></span><span class="hljs-function">): (</span><span class="hljs-function" style="color:#d08770">target: NzSafeAny, propName: </span><span class="hljs-function" style="color:#d08770">string</span><span class="hljs-function">) =&gt; </span><span class="hljs-function" style="color:#8fa1b3">void</span><span class="hljs-function"> </span><span>{
</span><span>  </span><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">propDecorator</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#d08770">
</span><span class="hljs-function" style="color:#d08770">    target: NzSafeAny,
</span><span class="hljs-function" style="color:#d08770">    propName: </span><span class="hljs-function" style="color:#d08770">string</span><span class="hljs-function" style="color:#d08770">,
</span><span class="hljs-function" style="color:#d08770">    originalDescriptor?: TypedPropertyDescriptor&lt;NzSafeAny&gt;
</span><span class="hljs-function" style="color:#d08770">  </span><span class="hljs-function">): </span><span class="hljs-function" style="color:#8fa1b3">NzSafeAny</span><span class="hljs-function"> </span><span>{
</span><span>    </span><span style="color:#b48ead">const</span><span> privatePropName = </span><span style="color:#a3be8c">`$$__zorroPropDecorator__</span><span class="hljs-subst" style="color:#a3be8c">${propName}</span><span style="color:#a3be8c">`</span><span>;
</span>
<span>    </span><span style="color:#b48ead">if</span><span> (</span><span style="color:#d08770">Object</span><span>.prototype.hasOwnProperty.call(target, privatePropName)) {
</span><span>      warn(</span><span style="color:#a3be8c">`The prop &quot;</span><span class="hljs-subst" style="color:#a3be8c">${privatePropName}</span><span style="color:#a3be8c">&quot; is already exist, it will be overrided by </span><span class="hljs-subst" style="color:#a3be8c">${name}</span><span style="color:#a3be8c"> decorator.`</span><span>);
</span>    }
<!-- -->
<span>    </span><span style="color:#d08770">Object</span><span>.defineProperty(target, privatePropName, {
</span><span>      </span><span class="hljs-attr">configurable</span><span>: </span><span style="color:#d08770">true</span><span>,
</span><span>      </span><span class="hljs-attr">writable</span><span>: </span><span style="color:#d08770">true</span><span>
</span>    });
<!-- -->
<span>    </span><span style="color:#b48ead">return</span><span> {
</span><span>      get(): </span><span style="color:#d08770">string</span><span> {
</span><span>        </span><span style="color:#b48ead">return</span><span> originalDescriptor &amp;&amp; originalDescriptor.get
</span><span>          ? originalDescriptor.get.bind(</span><span style="color:#d08770">this</span><span>)()
</span><span>          : </span><span style="color:#d08770">this</span><span>[privatePropName];
</span>      },
<span>      set(value: T): </span><span style="color:#d08770">void</span><span> {
</span><span>        </span><span style="color:#b48ead">if</span><span> (originalDescriptor &amp;&amp; originalDescriptor.set) {
</span><span>          originalDescriptor.set.bind(</span><span style="color:#d08770">this</span><span>)(fallback(value));
</span>        }
<span>        </span><span style="color:#d08770">this</span><span>[privatePropName] = fallback(value);
</span>      }
<!-- -->    };
<!-- -->  }
<!-- -->
<span>  </span><span style="color:#b48ead">return</span><span> propDecorator;
</span>}
<!-- -->
<span></span><span style="color:#b48ead">export</span><span> </span><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">InputBoolean</span><span class="hljs-function">(</span><span class="hljs-function">): </span><span class="hljs-function" style="color:#8fa1b3">NzSafeAny</span><span class="hljs-function"> </span><span>{
</span><span>  </span><span style="color:#b48ead">return</span><span> propDecoratorFactory(</span><span style="color:#a3be8c">&#x27;InputBoolean&#x27;</span><span>, toBoolean);
</span>}
<!-- -->
</code></pre>
</li>
<li>
<p>从全局配置中获取默认数值的装饰器</p>
<p>zorro提供了一个<code>NzConfigService</code>类，可以通过依赖注入的方式或者调用api的方式来设置组件的默认配置</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#b48ead">export</span><span> </span><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">WithConfig</span><span class="hljs-function">&lt;</span><span class="hljs-function" style="color:#8fa1b3">T</span><span class="hljs-function">&gt;(</span><span class="hljs-function">) </span><span>{
</span><span>  </span><span style="color:#b48ead">return</span><span> </span><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">ConfigDecorator</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#d08770">
</span><span class="hljs-function" style="color:#d08770">    target: NzSafeAny,
</span><span class="hljs-function" style="color:#d08770">    propName: NzSafeAny,
</span><span class="hljs-function" style="color:#d08770">    originalDescriptor?: TypedPropertyDescriptor&lt;T&gt;
</span><span class="hljs-function" style="color:#d08770">  </span><span class="hljs-function">): </span><span class="hljs-function" style="color:#8fa1b3">NzSafeAny</span><span class="hljs-function"> </span><span>{
</span><span>    </span><span style="color:#b48ead">const</span><span> privatePropName = </span><span style="color:#a3be8c">`$$__zorroConfigDecorator__</span><span class="hljs-subst" style="color:#a3be8c">${propName}</span><span style="color:#a3be8c">`</span><span>;
</span>
<span>    </span><span style="color:#d08770">Object</span><span>.defineProperty(target, privatePropName, {
</span><span>      </span><span class="hljs-attr">configurable</span><span>: </span><span style="color:#d08770">true</span><span>,
</span><span>      </span><span class="hljs-attr">writable</span><span>: </span><span style="color:#d08770">true</span><span>,
</span><span>      </span><span class="hljs-attr">enumerable</span><span>: </span><span style="color:#d08770">false</span><span>
</span>    });
<!-- -->
<span>    </span><span style="color:#b48ead">return</span><span> {
</span><span>      get(): T | </span><span style="color:#d08770">undefined</span><span> {
</span><span>        </span><span style="color:#b48ead">const</span><span> originalValue = originalDescriptor?.get ? originalDescriptor.get.bind(</span><span style="color:#d08770">this</span><span>)() : </span><span style="color:#d08770">this</span><span>[privatePropName];
</span><span>        </span><span style="color:#b48ead">const</span><span> assignedByUser = (</span><span style="color:#d08770">this</span><span>.propertyAssignCounter?.[propName] || </span><span style="color:#d08770">0</span><span>) &gt; </span><span style="color:#d08770">1</span><span>;
</span><span>        </span><span style="color:#b48ead">const</span><span> configValue = </span><span style="color:#d08770">this</span><span>.nzConfigService.getConfigForComponent(</span><span style="color:#d08770">this</span><span>._nzModuleName)?.[propName];
</span><span>        </span><span style="color:#b48ead">if</span><span> (assignedByUser &amp;&amp; isDefined(originalValue)) {
</span><span>          </span><span style="color:#b48ead">return</span><span> originalValue;
</span><span>        } </span><span style="color:#b48ead">else</span><span> {
</span><span>          </span><span style="color:#b48ead">return</span><span> isDefined(configValue) ? configValue : originalValue;
</span>        }
<!-- -->      },
<span>      set(value?: T): </span><span style="color:#d08770">void</span><span> {
</span><span>        </span><span style="color:#65737e">// If the value is assigned, we consider the newly assigned value as &#x27;assigned by user&#x27;.</span><span>
</span><span>        </span><span style="color:#d08770">this</span><span>.propertyAssignCounter = </span><span style="color:#d08770">this</span><span>.propertyAssignCounter || {};
</span><span>        </span><span style="color:#d08770">this</span><span>.propertyAssignCounter[propName] = (</span><span style="color:#d08770">this</span><span>.propertyAssignCounter[propName] || </span><span style="color:#d08770">0</span><span>) + </span><span style="color:#d08770">1</span><span>;
</span>
<span>        </span><span style="color:#b48ead">if</span><span> (originalDescriptor?.set) {
</span><span>          originalDescriptor.set.bind(</span><span style="color:#d08770">this</span><span>)(value!);
</span><span>        } </span><span style="color:#b48ead">else</span><span> {
</span><span>          </span><span style="color:#d08770">this</span><span>[privatePropName] = value;
</span>        }
<!-- -->      },
<span>      </span><span class="hljs-attr">configurable</span><span>: </span><span style="color:#d08770">true</span><span>,
</span><span>      </span><span class="hljs-attr">enumerable</span><span>: </span><span style="color:#d08770">true</span><span>
</span>    };
<!-- -->  };
<!-- -->}
<!-- -->
</code></pre>
<p>在组件中使用如下:</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#d08770">@Input</span><span>() </span><span style="color:#d08770">@WithConfig</span><span>() nzSize: NzSizeLDSType | </span><span style="color:#d08770">number</span><span> = </span><span style="color:#a3be8c">&#x27;default&#x27;</span><span>;
</span>
</code></pre>
<p>如何保证优先级?</p>
<p>组件调用&gt;用户配置&gt;默认配置</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#b48ead">const</span><span> assignedByUser = (</span><span style="color:#d08770">this</span><span>.propertyAssignCounter?.[propName] || </span><span style="color:#d08770">0</span><span>) &gt; </span><span style="color:#d08770">1</span><span>;
</span>
</code></pre>
<p>每次调用set的时候会+1，大于1说明用户自己设置了，使用用户设置的值，否则先读配置里，没有的话再读组件里的默认值。</p>
</li>
</ol>
<h2>使用<a href="https://v12.material.angular.io/cdk/overlay/overview">angular/cdk/overlay</a>对浮层进行统一管理</h2>
<p>为什么需要对浮层进行统一管理？</p>
<ul>
<li>规避父元素样式的影响（比如transition属性的影响）</li>
<li>在创建和销毁弹出层时，避免影响应用主体</li>
<li>方便 z-index 的设置与管理</li>
</ul>
<p>@angular/cdk的overlay模块提供了一套管理浮层的功能</p>
<p>使用大致如下：</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#b48ead">const</span><span> containerPortal = </span><span style="color:#b48ead">new</span><span> ComponentPortal&lt;BaseModalContainerComponent&gt;(
</span>      ContainerComponent,
<!-- -->      config.nzViewContainerRef,
<!-- -->      injector
<!-- -->    );
<span></span><span style="color:#b48ead">const</span><span> containerRef = overlayRef.attach&lt;BaseModalContainerComponent&gt;(containerPortal);
</span>
</code></pre></div></main><footer class="grid place-items-center pb-4"><a href="https://github.com/hmilin" target="_blank" rel="noreferrer noopener">😘Github</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h1: \"h1\",\n      p: \"p\",\n      h2: \"h2\",\n      pre: \"pre\",\n      code: \"code\",\n      a: \"a\",\n      ol: \"ol\",\n      li: \"li\",\n      ul: \"ul\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h1, {\n        children: \"Ng-Zorro代码鉴赏\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"目录\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-text\",\n          children: \"| 文件/文件名称 | 说明 | \\n| components | 组件文件夹，包含框架组件源码 |\\n| docs | 非组件文章文档，如国际化、全局配置等 |\\n| integration | 构建操作工具，搭配 travis 使用 |\\n| schematics | 自定义脚手架，ng g add ng-zorro-antd |\\n| scripts | 发布/调试脚本 |\\n| CODE_OF_CONDUCT.md | 贡献指南 |\\n| CHANGELOG.md | 发布日志 |\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"其中components/core 放了一些公共代码\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"关于和ant-design保持样式统一，他们使用了\", _jsx(_components.a, {\n          href: \"https://github.com/ng-zorro-bot\",\n          children: \"机器人\"\n        }), \"从ant-design同步样式代码。\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"ONPUSH变更检测模式的使用\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"angular中有两种检测模式，一种是CheckAlways，一种是CheckOnce，通过component装饰器的changeDetection字段来定义\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"@Component({\\n  changeDetection: ChangeDetectionStrategy.OnPush\\n})\\nexport declare enum ChangeDetectionStrategy {\\n    /**\\n     * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\\n     * until reactivated by setting the strategy to `Default` (`CheckAlways`).\\n     * Change detection can still be explicitly invoked.\\n     * This strategy applies to all child directives and cannot be overridden.\\n     */\\n    OnPush = 0,\\n    /**\\n     * Use the default `CheckAlways` strategy, in which change detection is automatic until\\n     * explicitly deactivated.\\n     */\\n    Default = 1\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"OnPush模式的使用:\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"由\", _jsx(_components.a, {\n          href: \"https://angular.cn/api/core/ChangeDetectorRef\",\n          children: \"ChangeDetectorRef\"\n        }), \"提供变更检测功能\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"abstract class ChangeDetectorRef {\\n  abstract markForCheck(): void // 当视图使用 OnPush（checkOnce）变更检测策略时，把该视图显式标记为已更改，以便它再次进行检查。\\n  abstract detach(): void // 从变更检测树中分离开视图。 \\n  abstract detectChanges(): void // 检查该视图及其子视图。\\n  abstract checkNoChanges(): void // 检查变更检测器及其子检测器，如果检测到任何更改，则抛出异常。\\n  abstract reattach(): void // 把以前分离开的视图重新附加到变更检测树上。 视图会被默认附加到这棵树上。\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"使用示例：\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"zorro中这段代码出现过很多次，作用是当全局配置中对应当前组件的配置修改时，将视图标记为需检测。\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"this.nzConfigService\\n    .getConfigChangeEventForComponent(NZ_CONFIG_COMPONENT_NAME)\\n    .pipe(takeUntil(this.destroy$))\\n    .subscribe(() =\u003e {\\n    this.cdr.markForCheck();\\n});\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"表单控件中，当writeVaule执行时（即将变化的数据写入视图时），标记为需检测。\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"writeValue(value: number): void {\\n    this.value = value;\\n    this.setValue(value);\\n    this.updateDisplayValue(value);\\n    this.cdr.markForCheck();\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.h2, {\n        children: [\"使用\", _jsx(_components.a, {\n          href: \"https://angular.cn/api/core/NgZone\",\n          children: \"NgZone\"\n        })]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Zone 是跨异步任务而持久存在的执行上下文。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"ngZone基于zone.js，是Angular变更检测的基础，Angular通过zone监听到了异步任务的执行过程，便于在异步任务执行时触发变更检测。\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"使用\", _jsx(_components.code, {\n          children: \"ngZone.runOutsideAngular\"\n        }), \"让代码执行不触发新的变更检测，在调用\", _jsx(_components.code, {\n          children: \"run\"\n        }), \"将这些任务重新进入Angular zone\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"this.ngZone.runOutsideAngular(() =\u003e {\\n      fromEvent\u003cMouseEvent\u003e(this.elementRef.nativeElement, 'click')\\n        .pipe(takeUntil(this.destroy$))\\n        .subscribe(event =\u003e {\\n          /** prevent label click triggered twice. **/\\n          event.stopPropagation();\\n          event.preventDefault();\\n          if (this.nzDisabled || this.isChecked) {\\n            return;\\n          }\\n          this.ngZone.run(() =\u003e {\\n            if (this.nzRadioService) {\\n              this.nzRadioService.select(this.nzValue);\\n            }\\n            if (this.isNgModel) {\\n              this.isChecked = true;\\n              this.onChange(true);\\n            }\\n            this.cdr.markForCheck();\\n          });\\n        });\\n    });\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"对templateRef传参的处理\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Zorro的组件中很多支持\", _jsx(_components.code, {\n          children: \"string | TemplateRef\u003cvoid\u003e\"\n        }), \"这种类型的传参，用于将字符串或模板植入组件视图。angular有一个\", _jsx(_components.a, {\n          href: \"https://angular.cn/api/common/NgTemplateOutlet\",\n          children: \"NgTemplateOutlet\"\n        }), \"指令，用于将templateRef插入视图，为了同时处理TemplateRef和string类型，zorro中封装了一个类似的指令\", _jsx(_components.code, {\n          children: \"nzStringTemplateOutlet\"\n        }), \"。\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"核心代码为\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"constructor(private viewContainer: ViewContainerRef, private templateRef: TemplateRef\u003cNzSafeAny\u003e) {}\\n\\nprivate recreateView(): void {\\n    this.viewContainer.clear();\\n    const isTemplateRef = this.nzStringTemplateOutlet instanceof TemplateRef;\\n    const templateRef = (isTemplateRef ? this.nzStringTemplateOutlet : this.templateRef) as NzSafeAny;\\n    this.embeddedViewRef = this.viewContainer.createEmbeddedView(\\n    templateRef,\\n    isTemplateRef ? this.nzStringTemplateOutletContext : this.context\\n    );\\n}\\n  \\nngOnChanges(changes: SimpleChanges): void {\\n    // ...\\n     if (recreateView) {\\n      /** recreate view when context shape or outlet change **/\\n      this.recreateView();\\n    } else {\\n    // ...\\n\\t}\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"在很多个组件文件里都能看到他的使用，大概如下:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"\u003cng-container *nzStringTemplateOutlet=\\\"nzMessage\\\"\u003e{{ nzMessage }}\u003c/ng-container\u003e\\n@Input() nzMessage: string | TemplateRef\u003cvoid\u003e | null = null;\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"指令是Angular中用于封装公共行为的强有力工具，它拥有了对模板的控制权，和组件一样拥有生命周期，但是使用起来更灵活。\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"对装饰器的使用\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"属性装饰器\"\n          }), \"\\n\", _jsx(_components.p, {\n            children: \"zorro中基本每一个组件都会看到@InputNumber、@InputBoolean这样的装饰器使用，用于对输入参数进行强制类型转换，避免因类型错误影响后面程序运行。\"\n          }), \"\\n\", _jsx(_components.p, {\n            children: \"在typescript中声明一个工厂装饰器的思路大致如下：\"\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-typescript\",\n              children: \"function name () {\\n    return function(target: IConfirmableDirective, propertyKey: string, descriptor: PropertyDescriptor) {\\n            // TODO 对装饰对象的处理，并返回新的descriptor\\n    }\\n}\\n\\n\"\n            })\n          }), \"\\n\", _jsx(_components.p, {\n            children: \"zorro中定义了一个生产属性装饰器的函数，传入装饰器名称和对属性的处理函数，即可生成一个装饰器。\"\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-typescript\",\n              children: \"function propDecoratorFactory\u003cT, D\u003e(\\n  name: string,\\n  fallback: (v: T) =\u003e D\\n): (target: NzSafeAny, propName: string) =\u003e void {\\n  function propDecorator(\\n    target: NzSafeAny,\\n    propName: string,\\n    originalDescriptor?: TypedPropertyDescriptor\u003cNzSafeAny\u003e\\n  ): NzSafeAny {\\n    const privatePropName = `$$__zorroPropDecorator__${propName}`;\\n\\n    if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {\\n      warn(`The prop \\\"${privatePropName}\\\" is already exist, it will be overrided by ${name} decorator.`);\\n    }\\n\\n    Object.defineProperty(target, privatePropName, {\\n      configurable: true,\\n      writable: true\\n    });\\n\\n    return {\\n      get(): string {\\n        return originalDescriptor \u0026\u0026 originalDescriptor.get\\n          ? originalDescriptor.get.bind(this)()\\n          : this[privatePropName];\\n      },\\n      set(value: T): void {\\n        if (originalDescriptor \u0026\u0026 originalDescriptor.set) {\\n          originalDescriptor.set.bind(this)(fallback(value));\\n        }\\n        this[privatePropName] = fallback(value);\\n      }\\n    };\\n  }\\n\\n  return propDecorator;\\n}\\n\\nexport function InputBoolean(): NzSafeAny {\\n  return propDecoratorFactory('InputBoolean', toBoolean);\\n}\\n\\n\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"从全局配置中获取默认数值的装饰器\"\n          }), \"\\n\", _jsxs(_components.p, {\n            children: [\"zorro提供了一个\", _jsx(_components.code, {\n              children: \"NzConfigService\"\n            }), \"类，可以通过依赖注入的方式或者调用api的方式来设置组件的默认配置\"]\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-typescript\",\n              children: \"export function WithConfig\u003cT\u003e() {\\n  return function ConfigDecorator(\\n    target: NzSafeAny,\\n    propName: NzSafeAny,\\n    originalDescriptor?: TypedPropertyDescriptor\u003cT\u003e\\n  ): NzSafeAny {\\n    const privatePropName = `$$__zorroConfigDecorator__${propName}`;\\n\\n    Object.defineProperty(target, privatePropName, {\\n      configurable: true,\\n      writable: true,\\n      enumerable: false\\n    });\\n\\n    return {\\n      get(): T | undefined {\\n        const originalValue = originalDescriptor?.get ? originalDescriptor.get.bind(this)() : this[privatePropName];\\n        const assignedByUser = (this.propertyAssignCounter?.[propName] || 0) \u003e 1;\\n        const configValue = this.nzConfigService.getConfigForComponent(this._nzModuleName)?.[propName];\\n        if (assignedByUser \u0026\u0026 isDefined(originalValue)) {\\n          return originalValue;\\n        } else {\\n          return isDefined(configValue) ? configValue : originalValue;\\n        }\\n      },\\n      set(value?: T): void {\\n        // If the value is assigned, we consider the newly assigned value as 'assigned by user'.\\n        this.propertyAssignCounter = this.propertyAssignCounter || {};\\n        this.propertyAssignCounter[propName] = (this.propertyAssignCounter[propName] || 0) + 1;\\n\\n        if (originalDescriptor?.set) {\\n          originalDescriptor.set.bind(this)(value!);\\n        } else {\\n          this[privatePropName] = value;\\n        }\\n      },\\n      configurable: true,\\n      enumerable: true\\n    };\\n  };\\n}\\n\\n\"\n            })\n          }), \"\\n\", _jsx(_components.p, {\n            children: \"在组件中使用如下:\"\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-typescript\",\n              children: \"@Input() @WithConfig() nzSize: NzSizeLDSType | number = 'default';\\n\\n\"\n            })\n          }), \"\\n\", _jsx(_components.p, {\n            children: \"如何保证优先级?\"\n          }), \"\\n\", _jsx(_components.p, {\n            children: \"组件调用\u003e用户配置\u003e默认配置\"\n          }), \"\\n\", _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-typescript\",\n              children: \"const assignedByUser = (this.propertyAssignCounter?.[propName] || 0) \u003e 1;\\n\\n\"\n            })\n          }), \"\\n\", _jsx(_components.p, {\n            children: \"每次调用set的时候会+1，大于1说明用户自己设置了，使用用户设置的值，否则先读配置里，没有的话再读组件里的默认值。\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.h2, {\n        children: [\"使用\", _jsx(_components.a, {\n          href: \"https://v12.material.angular.io/cdk/overlay/overview\",\n          children: \"angular/cdk/overlay\"\n        }), \"对浮层进行统一管理\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"为什么需要对浮层进行统一管理？\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"规避父元素样式的影响（比如transition属性的影响）\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"在创建和销毁弹出层时，避免影响应用主体\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"方便 z-index 的设置与管理\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"@angular/cdk的overlay模块提供了一套管理浮层的功能\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"使用大致如下：\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"const containerPortal = new ComponentPortal\u003cBaseModalContainerComponent\u003e(\\n      ContainerComponent,\\n      config.nzViewContainerRef,\\n      injector\\n    );\\nconst containerRef = overlayRef.attach\u003cBaseModalContainerComponent\u003e(containerPortal);\\n\\n\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"Ng-Zorro代码鉴赏","date":"2021-12-10 13:55:00","description":"Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。"}},"frontMatter":{"title":"Ng-Zorro代码鉴赏","date":"2021-12-10 13:55:00","description":"Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"ng-zorro-study"},"buildId":"eQHzwepfXML6lMuZMdrtB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>