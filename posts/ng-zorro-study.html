<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Meiling&#x27;s Blog</title><meta name="description" content="meiling的博客"/><link rel="icon" href="/favicon.ico"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/80aacda1f17f20ec.css" as="style"/><link rel="stylesheet" href="/_next/static/css/80aacda1f17f20ec.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a85178c7df1bcd20.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a85178c7df1bcd20.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-c50d706355616eef.js" defer=""></script><script src="/_next/static/chunks/framework-a85322f027b40e20.js" defer=""></script><script src="/_next/static/chunks/main-95aa3232ca423ead.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c28c633855fb2140.js" defer=""></script><script src="/_next/static/chunks/495-31a10f133dd42cb0.js" defer=""></script><script src="/_next/static/chunks/785-afa51abc884a1702.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-aa35ebeedcc516ae.js" defer=""></script><script src="/_next/static/dFrmMN50ll23FrSW9hL6z/_buildManifest.js" defer=""></script><script src="/_next/static/dFrmMN50ll23FrSW9hL6z/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_container__XDtoS"><header class="Header_header__aO32P"><div class="Header_mobileNav__x8dOm"><div class="Header_menuIcon__zsaJW"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M120-240v-80h720v80zm0-200v-80h720v80zm0-200v-80h720v80z"></path></svg></div><a class="Header_searchBtn__DiCC5" href="/search"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580t75.5-184.5T380-840t184.5 75.5T640-580q0 44-14 83t-38 69l252 252zM380-400q75 0 127.5-52.5T560-580t-52.5-127.5T380-760t-127.5 52.5T200-580t52.5 127.5T380-400"></path></svg></a></div><nav class="Header_nav__wk8Zc"><div class="Header_closeIcon__TBNuf"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224z"></path></svg></div><a class="Header_searchBtn__DiCC5" href="/search"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580t75.5-184.5T380-840t184.5 75.5T640-580q0 44-14 83t-38 69l252 252zM380-400q75 0 127.5-52.5T560-580t-52.5-127.5T380-760t-127.5 52.5T200-580t52.5 127.5T380-400"></path></svg></a><a class="" href="/"><div class="Header_icon__SYetk"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M200-160v-366L88-440l-48-64 440-336 160 122v-82h120v174l160 122-48 64-112-86v366H520v-240h-80v240zm80-80h80v-240h240v240h80v-347L480-739 280-587zm120-319h160q0-32-24-52.5T480-632t-56 20.5-24 52.5m-40 319v-240h240v240-240H360z"></path></svg></div><div class="Header_title__BTC6R">首页</div></a><a class="" href="/category/native"><div class="Header_icon__SYetk"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M200-640v440h560v-440H640v320l-160-80-160 80v-320zm0 520q-33 0-56.5-23.5T120-200v-499q0-14 4.5-27t13.5-24l50-61q11-14 27.5-21.5T250-840h460q18 0 34.5 7.5T772-811l50 61q9 11 13.5 24t4.5 27v499q0 33-23.5 56.5T760-120zm16-600h528l-34-40H250zm184 80v190l80-40 80 40v-190zm-200 0h560z"></path></svg></div><div class="Header_title__BTC6R">原生基础</div></a><a class="" href="/category/framework"><div class="Header_icon__SYetk"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M400-400h160v-80H400zm0-120h320v-80H400zm0-120h320v-80H400zm-80 400q-33 0-56.5-23.5T240-320v-480q0-33 23.5-56.5T320-880h480q33 0 56.5 23.5T880-800v480q0 33-23.5 56.5T800-240zm0-80h480v-480H320zM160-80q-33 0-56.5-23.5T80-160v-560h80v560h560v80zm160-720v480z"></path></svg></div><div class="Header_title__BTC6R">框架相关</div></a><a class="" href="/category/tool"><div class="Header_icon__SYetk"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="m620-284 56-56q6-6 6-14t-6-14L540-505q4-11 6-22t2-25q0-57-40.5-97.5T410-690q-17 0-34 4.5T343-673l94 94-56 56-94-94q-8 16-12.5 33t-4.5 34q0 57 40.5 97.5T408-412q13 0 24.5-2t22.5-6l137 136q6 6 14 6t14-6M480-80q-83 0-156-31.5T197-197t-85.5-127T80-480t31.5-156T197-763t127-85.5T480-880t156 31.5T763-763t85.5 127T880-480t-31.5 156T763-197t-127 85.5T480-80m0-80q134 0 227-93t93-227-93-227-227-93-227 93-93 227 93 227 227 93m0-320"></path></svg></div><div class="Header_title__BTC6R">工具使用</div></a><a class="" href="/category/performance"><div class="Header_icon__SYetk"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M220-520 80-600v-160l140-80 140 80v160zm0-92 60-34v-68l-60-34-60 34v68zm440 123v-93l140 82v280L560-80 320-220v-280l140-82v93l-60 35v188l160 93 160-93v-188zm-140 89v-480h360l-80 120 80 120H600v240zM220-680"></path></svg></div><div class="Header_title__BTC6R">性能提升</div></a><a class="" href="/about"><div class="Header_icon__SYetk"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M360-390q-21 0-35.5-14.5T310-440t14.5-35.5T360-490t35.5 14.5T410-440t-14.5 35.5T360-390m240 0q-21 0-35.5-14.5T550-440t14.5-35.5T600-490t35.5 14.5T650-440t-14.5 35.5T600-390M480-160q134 0 227-93t93-227q0-24-3-46.5T786-570q-21 5-42 7.5t-44 2.5q-91 0-172-39T390-708q-32 78-91.5 135.5T160-486v6q0 134 93 227t227 93m0 80q-83 0-156-31.5T197-197t-85.5-127T80-480t31.5-156T197-763t127-85.5T480-880t156 31.5T763-763t85.5 127T880-480t-31.5 156T763-197t-127 85.5T480-80m-54-715q42 70 114 112.5T700-640q14 0 27-1.5t27-3.5q-42-70-114-112.5T480-800q-14 0-27 1.5t-27 3.5M177-581q51-29 89-75t57-103q-51 29-89 75t-57 103m146-178"></path></svg></div><div class="Header_title__BTC6R">关于</div></a></nav></header><div><main><div class="Layout_cover__vC5GW"><div><h1>Ng-Zorro代码鉴赏</h1><p>Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。</p><div>2021-12-10 13:55:00</div></div></div><div class="content-container"><h1 id="Ng-Zorro代码鉴赏"><a href="#Ng-Zorro代码鉴赏" class="mr-2">#</a>Ng-Zorro代码鉴赏</h1>
<p>Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。</p>
<h2 id="目录"><a href="#目录" class="mr-2">#</a>目录</h2>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span>| 文件/文件名称 | 说明 | 
</span>| components | 组件文件夹，包含框架组件源码 |
<!-- -->| docs | 非组件文章文档，如国际化、全局配置等 |
<!-- -->| integration | 构建操作工具，搭配 travis 使用 |
<!-- -->| schematics | 自定义脚手架，ng g add ng-zorro-antd |
<!-- -->| scripts | 发布/调试脚本 |
<!-- -->| CODE_OF_CONDUCT.md | 贡献指南 |
<!-- -->| CHANGELOG.md | 发布日志 |
</code></pre>
<p>其中components/core 放了一些公共代码</p>
<p>关于和ant-design保持样式统一，他们使用了<a href="https://github.com/ng-zorro-bot">机器人</a>从ant-design同步样式代码。</p>
<h2 id="ONPUSH变更检测模式的使用"><a href="#ONPUSH变更检测模式的使用" class="mr-2">#</a>ONPUSH变更检测模式的使用</h2>
<p>angular中有两种检测模式，一种是CheckAlways，一种是CheckOnce，通过component装饰器的changeDetection字段来定义</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span>@Component({
</span>  changeDetection: ChangeDetectionStrategy.OnPush
<!-- -->})
<span>export </span><span style="color:#b48ead">declare</span><span> </span><span style="color:#b48ead">enum</span><span> ChangeDetectionStrategy {
</span>    /**
<span>     * Use the `CheckOnce` strategy, meaning that automatic change detection </span><span style="color:#d08770">is</span><span> deactivated
</span><span>     * </span><span style="color:#b48ead">until</span><span> reactivated </span><span style="color:#b48ead">by</span><span> setting the strategy </span><span style="color:#b48ead">to</span><span> `</span><span style="color:#b48ead">Default</span><span>` (`CheckAlways`).
</span>     * Change detection can still be explicitly invoked.
<span>     * This strategy applies </span><span style="color:#b48ead">to</span><span> all child directives </span><span style="color:#d08770">and</span><span> cannot be overridden.
</span>     */
<span>    OnPush = </span><span style="color:#d08770">0</span><span>,
</span>    /**
<span>     * Use the </span><span style="color:#b48ead">default</span><span> `CheckAlways` strategy, </span><span style="color:#b48ead">in</span><span> which change detection </span><span style="color:#d08770">is</span><span> automatic </span><span style="color:#b48ead">until</span><span>
</span>     * explicitly deactivated.
<!-- -->     */
<span>    </span><span style="color:#b48ead">Default</span><span> = </span><span style="color:#d08770">1</span><span>
</span>}
</code></pre>
<p>OnPush模式的使用:</p>
<p>由<a href="https://angular.cn/api/core/ChangeDetectorRef">ChangeDetectorRef</a>提供变更检测功能</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#b48ead">abstract</span><span> </span><span class="hljs-class" style="color:#b48ead">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#8fa1b3">ChangeDetectorRef</span><span class="hljs-class"> </span><span>{
</span><span>  </span><span style="color:#b48ead">abstract</span><span> markForCheck(): </span><span style="color:#d08770">void</span><span> </span><span style="color:#65737e">// 当视图使用 OnPush（checkOnce）变更检测策略时，把该视图显式标记为已更改，以便它再次进行检查。</span><span>
</span><span>  </span><span style="color:#b48ead">abstract</span><span> detach(): </span><span style="color:#d08770">void</span><span> </span><span style="color:#65737e">// 从变更检测树中分离开视图。 </span><span>
</span><span>  </span><span style="color:#b48ead">abstract</span><span> detectChanges(): </span><span style="color:#d08770">void</span><span> </span><span style="color:#65737e">// 检查该视图及其子视图。</span><span>
</span><span>  </span><span style="color:#b48ead">abstract</span><span> checkNoChanges(): </span><span style="color:#d08770">void</span><span> </span><span style="color:#65737e">// 检查变更检测器及其子检测器，如果检测到任何更改，则抛出异常。</span><span>
</span><span>  </span><span style="color:#b48ead">abstract</span><span> reattach(): </span><span style="color:#d08770">void</span><span> </span><span style="color:#65737e">// 把以前分离开的视图重新附加到变更检测树上。 视图会被默认附加到这棵树上。</span><span>
</span>}
</code></pre>
<p>使用示例：</p>
<p>zorro中这段代码出现过很多次，作用是当全局配置中对应当前组件的配置修改时，将视图标记为需检测。</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#d08770">this</span><span>.nzConfigService
</span>    .getConfigChangeEventForComponent(NZ_CONFIG_COMPONENT_NAME)
<span>    .pipe(takeUntil(</span><span style="color:#d08770">this</span><span>.destroy$))
</span><span>    .subscribe(</span><span class="hljs-function">() =&gt;</span><span> {
</span><span>    </span><span style="color:#d08770">this</span><span>.cdr.markForCheck();
</span>});
</code></pre>
<p>表单控件中，当writeVaule执行时（即将变化的数据写入视图时），标记为需检测。</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span>writeValue(value: </span><span style="color:#d08770">number</span><span>): </span><span style="color:#d08770">void</span><span> {
</span><span>    </span><span style="color:#d08770">this</span><span>.value = value;
</span><span>    </span><span style="color:#d08770">this</span><span>.setValue(value);
</span><span>    </span><span style="color:#d08770">this</span><span>.updateDisplayValue(value);
</span><span>    </span><span style="color:#d08770">this</span><span>.cdr.markForCheck();
</span>}
</code></pre>
<h2 id="使用,[object Object]"><a href="#使用,[object Object]" class="mr-2">#</a>使用<a href="https://angular.cn/api/core/NgZone">NgZone</a></h2>
<p>Zone 是跨异步任务而持久存在的执行上下文。</p>
<p>ngZone基于zone.js，是Angular变更检测的基础，Angular通过zone监听到了异步任务的执行过程，便于在异步任务执行时触发变更检测。</p>
<p>使用<code>ngZone.runOutsideAngular</code>让代码执行不触发新的变更检测，在调用<code>run</code>将这些任务重新进入Angular zone</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#d08770">this</span><span>.ngZone.runOutsideAngular(</span><span class="hljs-function">() =&gt;</span><span> {
</span><span>      fromEvent&lt;MouseEvent&gt;(</span><span style="color:#d08770">this</span><span>.elementRef.nativeElement, </span><span style="color:#a3be8c">&#x27;click&#x27;</span><span>)
</span><span>        .pipe(takeUntil(</span><span style="color:#d08770">this</span><span>.destroy$))
</span><span>        .subscribe(</span><span class="hljs-function" style="color:#d08770">event</span><span class="hljs-function"> =&gt;</span><span> {
</span><span>          </span><span style="color:#65737e">/** prevent label click triggered twice. **/</span><span>
</span>          event.stopPropagation();
<!-- -->          event.preventDefault();
<span>          </span><span style="color:#b48ead">if</span><span> (</span><span style="color:#d08770">this</span><span>.nzDisabled || </span><span style="color:#d08770">this</span><span>.isChecked) {
</span><span>            </span><span style="color:#b48ead">return</span><span>;
</span>          }
<span>          </span><span style="color:#d08770">this</span><span>.ngZone.run(</span><span class="hljs-function">() =&gt;</span><span> {
</span><span>            </span><span style="color:#b48ead">if</span><span> (</span><span style="color:#d08770">this</span><span>.nzRadioService) {
</span><span>              </span><span style="color:#d08770">this</span><span>.nzRadioService.select(</span><span style="color:#d08770">this</span><span>.nzValue);
</span>            }
<span>            </span><span style="color:#b48ead">if</span><span> (</span><span style="color:#d08770">this</span><span>.isNgModel) {
</span><span>              </span><span style="color:#d08770">this</span><span>.isChecked = </span><span style="color:#d08770">true</span><span>;
</span><span>              </span><span style="color:#d08770">this</span><span>.onChange(</span><span style="color:#d08770">true</span><span>);
</span>            }
<span>            </span><span style="color:#d08770">this</span><span>.cdr.markForCheck();
</span>          });
<!-- -->        });
<!-- -->    });
</code></pre>
<h2 id="对templateRef传参的处理"><a href="#对templateRef传参的处理" class="mr-2">#</a>对templateRef传参的处理</h2>
<p>Zorro的组件中很多支持<code>string | TemplateRef&lt;void&gt;</code>这种类型的传参，用于将字符串或模板植入组件视图。angular有一个<a href="https://angular.cn/api/common/NgTemplateOutlet">NgTemplateOutlet</a>指令，用于将templateRef插入视图，为了同时处理TemplateRef和string类型，zorro中封装了一个类似的指令<code>nzStringTemplateOutlet</code>。</p>
<p>核心代码为</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span class="hljs-function" style="color:#8fa1b3">constructor</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#b48ead">private</span><span class="hljs-function" style="color:#d08770"> viewContainer: ViewContainerRef, </span><span class="hljs-function" style="color:#b48ead">private</span><span class="hljs-function" style="color:#d08770"> templateRef: TemplateRef&lt;NzSafeAny&gt;</span><span class="hljs-function">)</span><span> {}
</span>
<span></span><span style="color:#b48ead">private</span><span> recreateView(): </span><span style="color:#d08770">void</span><span> {
</span><span>    </span><span style="color:#d08770">this</span><span>.viewContainer.clear();
</span><span>    </span><span style="color:#b48ead">const</span><span> isTemplateRef = </span><span style="color:#d08770">this</span><span>.nzStringTemplateOutlet </span><span style="color:#b48ead">instanceof</span><span> TemplateRef;
</span><span>    </span><span style="color:#b48ead">const</span><span> templateRef = (isTemplateRef ? </span><span style="color:#d08770">this</span><span>.nzStringTemplateOutlet : </span><span style="color:#d08770">this</span><span>.templateRef) </span><span style="color:#b48ead">as</span><span> NzSafeAny;
</span><span>    </span><span style="color:#d08770">this</span><span>.embeddedViewRef = </span><span style="color:#d08770">this</span><span>.viewContainer.createEmbeddedView(
</span>    templateRef,
<span>    isTemplateRef ? </span><span style="color:#d08770">this</span><span>.nzStringTemplateOutletContext : </span><span style="color:#d08770">this</span><span>.context
</span>    );
<!-- -->}
<!-- -->  
<span>ngOnChanges(changes: SimpleChanges): </span><span style="color:#d08770">void</span><span> {
</span><span>    </span><span style="color:#65737e">// ...</span><span>
</span><span>     </span><span style="color:#b48ead">if</span><span> (recreateView) {
</span><span>      </span><span style="color:#65737e">/** recreate view when context shape or outlet change **/</span><span>
</span><span>      </span><span style="color:#d08770">this</span><span>.recreateView();
</span><span>    } </span><span style="color:#b48ead">else</span><span> {
</span><span>    </span><span style="color:#65737e">// ...</span><span>
</span>	}
<!-- -->}
</code></pre>
<p>在很多个组件文件里都能看到他的使用，大概如下:</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span>&lt;ng-container *nzStringTemplateOutlet=</span><span style="color:#a3be8c">&quot;nzMessage&quot;</span><span>&gt;{{ nzMessage }}&lt;/ng-container&gt;
</span><span></span><span style="color:#d08770">@Input</span><span>() nzMessage: </span><span style="color:#d08770">string</span><span> | TemplateRef&lt;</span><span style="color:#d08770">void</span><span>&gt; | </span><span style="color:#d08770">null</span><span> = </span><span style="color:#d08770">null</span><span>;
</span></code></pre>
<p>指令是Angular中用于封装公共行为的强有力工具，它拥有了对模板的控制权，和组件一样拥有生命周期，但是使用起来更灵活。</p>
<h2 id="对装饰器的使用"><a href="#对装饰器的使用" class="mr-2">#</a>对装饰器的使用</h2>
<ol>
<li>
<p>属性装饰器</p>
<p>zorro中基本每一个组件都会看到@InputNumber、@InputBoolean这样的装饰器使用，用于对输入参数进行强制类型转换，避免因类型错误影响后面程序运行。</p>
<p>在typescript中声明一个工厂装饰器的思路大致如下：</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">name</span><span class="hljs-function"> (</span><span class="hljs-function">) </span><span>{
</span><span>    </span><span style="color:#b48ead">return</span><span> </span><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#d08770">target: IConfirmableDirective, propertyKey: </span><span class="hljs-function" style="color:#d08770">string</span><span class="hljs-function" style="color:#d08770">, descriptor: PropertyDescriptor</span><span class="hljs-function">) </span><span>{
</span><span>            </span><span style="color:#65737e">// TODO 对装饰对象的处理，并返回新的descriptor</span><span>
</span>    }
<!-- -->}
<!-- -->
</code></pre>
<p>zorro中定义了一个生产属性装饰器的函数，传入装饰器名称和对属性的处理函数，即可生成一个装饰器。</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">propDecoratorFactory</span><span class="hljs-function">&lt;</span><span class="hljs-function" style="color:#8fa1b3">T</span><span class="hljs-function">, </span><span class="hljs-function" style="color:#8fa1b3">D</span><span class="hljs-function">&gt;(</span><span class="hljs-function" style="color:#d08770">
</span><span class="hljs-function" style="color:#d08770">  name: </span><span class="hljs-function" style="color:#d08770">string</span><span class="hljs-function" style="color:#d08770">,
</span><span class="hljs-function" style="color:#d08770">  fallback: (v: T) =&gt; D
</span><span class="hljs-function" style="color:#d08770"></span><span class="hljs-function">): (</span><span class="hljs-function" style="color:#d08770">target: NzSafeAny, propName: </span><span class="hljs-function" style="color:#d08770">string</span><span class="hljs-function">) =&gt; </span><span class="hljs-function" style="color:#8fa1b3">void</span><span class="hljs-function"> </span><span>{
</span><span>  </span><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">propDecorator</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#d08770">
</span><span class="hljs-function" style="color:#d08770">    target: NzSafeAny,
</span><span class="hljs-function" style="color:#d08770">    propName: </span><span class="hljs-function" style="color:#d08770">string</span><span class="hljs-function" style="color:#d08770">,
</span><span class="hljs-function" style="color:#d08770">    originalDescriptor?: TypedPropertyDescriptor&lt;NzSafeAny&gt;
</span><span class="hljs-function" style="color:#d08770">  </span><span class="hljs-function">): </span><span class="hljs-function" style="color:#8fa1b3">NzSafeAny</span><span class="hljs-function"> </span><span>{
</span><span>    </span><span style="color:#b48ead">const</span><span> privatePropName = </span><span style="color:#a3be8c">`$$__zorroPropDecorator__</span><span class="hljs-subst" style="color:#a3be8c">${propName}</span><span style="color:#a3be8c">`</span><span>;
</span>
<span>    </span><span style="color:#b48ead">if</span><span> (</span><span style="color:#d08770">Object</span><span>.prototype.hasOwnProperty.call(target, privatePropName)) {
</span><span>      warn(</span><span style="color:#a3be8c">`The prop &quot;</span><span class="hljs-subst" style="color:#a3be8c">${privatePropName}</span><span style="color:#a3be8c">&quot; is already exist, it will be overrided by </span><span class="hljs-subst" style="color:#a3be8c">${name}</span><span style="color:#a3be8c"> decorator.`</span><span>);
</span>    }
<!-- -->
<span>    </span><span style="color:#d08770">Object</span><span>.defineProperty(target, privatePropName, {
</span><span>      </span><span class="hljs-attr">configurable</span><span>: </span><span style="color:#d08770">true</span><span>,
</span><span>      </span><span class="hljs-attr">writable</span><span>: </span><span style="color:#d08770">true</span><span>
</span>    });
<!-- -->
<span>    </span><span style="color:#b48ead">return</span><span> {
</span><span>      get(): </span><span style="color:#d08770">string</span><span> {
</span><span>        </span><span style="color:#b48ead">return</span><span> originalDescriptor &amp;&amp; originalDescriptor.get
</span><span>          ? originalDescriptor.get.bind(</span><span style="color:#d08770">this</span><span>)()
</span><span>          : </span><span style="color:#d08770">this</span><span>[privatePropName];
</span>      },
<span>      set(value: T): </span><span style="color:#d08770">void</span><span> {
</span><span>        </span><span style="color:#b48ead">if</span><span> (originalDescriptor &amp;&amp; originalDescriptor.set) {
</span><span>          originalDescriptor.set.bind(</span><span style="color:#d08770">this</span><span>)(fallback(value));
</span>        }
<span>        </span><span style="color:#d08770">this</span><span>[privatePropName] = fallback(value);
</span>      }
<!-- -->    };
<!-- -->  }
<!-- -->
<span>  </span><span style="color:#b48ead">return</span><span> propDecorator;
</span>}
<!-- -->
<span></span><span style="color:#b48ead">export</span><span> </span><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">InputBoolean</span><span class="hljs-function">(</span><span class="hljs-function">): </span><span class="hljs-function" style="color:#8fa1b3">NzSafeAny</span><span class="hljs-function"> </span><span>{
</span><span>  </span><span style="color:#b48ead">return</span><span> propDecoratorFactory(</span><span style="color:#a3be8c">&#x27;InputBoolean&#x27;</span><span>, toBoolean);
</span>}
<!-- -->
</code></pre>
</li>
<li>
<p>从全局配置中获取默认数值的装饰器</p>
<p>zorro提供了一个<code>NzConfigService</code>类，可以通过依赖注入的方式或者调用api的方式来设置组件的默认配置</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#b48ead">export</span><span> </span><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">WithConfig</span><span class="hljs-function">&lt;</span><span class="hljs-function" style="color:#8fa1b3">T</span><span class="hljs-function">&gt;(</span><span class="hljs-function">) </span><span>{
</span><span>  </span><span style="color:#b48ead">return</span><span> </span><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">ConfigDecorator</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#d08770">
</span><span class="hljs-function" style="color:#d08770">    target: NzSafeAny,
</span><span class="hljs-function" style="color:#d08770">    propName: NzSafeAny,
</span><span class="hljs-function" style="color:#d08770">    originalDescriptor?: TypedPropertyDescriptor&lt;T&gt;
</span><span class="hljs-function" style="color:#d08770">  </span><span class="hljs-function">): </span><span class="hljs-function" style="color:#8fa1b3">NzSafeAny</span><span class="hljs-function"> </span><span>{
</span><span>    </span><span style="color:#b48ead">const</span><span> privatePropName = </span><span style="color:#a3be8c">`$$__zorroConfigDecorator__</span><span class="hljs-subst" style="color:#a3be8c">${propName}</span><span style="color:#a3be8c">`</span><span>;
</span>
<span>    </span><span style="color:#d08770">Object</span><span>.defineProperty(target, privatePropName, {
</span><span>      </span><span class="hljs-attr">configurable</span><span>: </span><span style="color:#d08770">true</span><span>,
</span><span>      </span><span class="hljs-attr">writable</span><span>: </span><span style="color:#d08770">true</span><span>,
</span><span>      </span><span class="hljs-attr">enumerable</span><span>: </span><span style="color:#d08770">false</span><span>
</span>    });
<!-- -->
<span>    </span><span style="color:#b48ead">return</span><span> {
</span><span>      get(): T | </span><span style="color:#d08770">undefined</span><span> {
</span><span>        </span><span style="color:#b48ead">const</span><span> originalValue = originalDescriptor?.get ? originalDescriptor.get.bind(</span><span style="color:#d08770">this</span><span>)() : </span><span style="color:#d08770">this</span><span>[privatePropName];
</span><span>        </span><span style="color:#b48ead">const</span><span> assignedByUser = (</span><span style="color:#d08770">this</span><span>.propertyAssignCounter?.[propName] || </span><span style="color:#d08770">0</span><span>) &gt; </span><span style="color:#d08770">1</span><span>;
</span><span>        </span><span style="color:#b48ead">const</span><span> configValue = </span><span style="color:#d08770">this</span><span>.nzConfigService.getConfigForComponent(</span><span style="color:#d08770">this</span><span>._nzModuleName)?.[propName];
</span><span>        </span><span style="color:#b48ead">if</span><span> (assignedByUser &amp;&amp; isDefined(originalValue)) {
</span><span>          </span><span style="color:#b48ead">return</span><span> originalValue;
</span><span>        } </span><span style="color:#b48ead">else</span><span> {
</span><span>          </span><span style="color:#b48ead">return</span><span> isDefined(configValue) ? configValue : originalValue;
</span>        }
<!-- -->      },
<span>      set(value?: T): </span><span style="color:#d08770">void</span><span> {
</span><span>        </span><span style="color:#65737e">// If the value is assigned, we consider the newly assigned value as &#x27;assigned by user&#x27;.</span><span>
</span><span>        </span><span style="color:#d08770">this</span><span>.propertyAssignCounter = </span><span style="color:#d08770">this</span><span>.propertyAssignCounter || {};
</span><span>        </span><span style="color:#d08770">this</span><span>.propertyAssignCounter[propName] = (</span><span style="color:#d08770">this</span><span>.propertyAssignCounter[propName] || </span><span style="color:#d08770">0</span><span>) + </span><span style="color:#d08770">1</span><span>;
</span>
<span>        </span><span style="color:#b48ead">if</span><span> (originalDescriptor?.set) {
</span><span>          originalDescriptor.set.bind(</span><span style="color:#d08770">this</span><span>)(value!);
</span><span>        } </span><span style="color:#b48ead">else</span><span> {
</span><span>          </span><span style="color:#d08770">this</span><span>[privatePropName] = value;
</span>        }
<!-- -->      },
<span>      </span><span class="hljs-attr">configurable</span><span>: </span><span style="color:#d08770">true</span><span>,
</span><span>      </span><span class="hljs-attr">enumerable</span><span>: </span><span style="color:#d08770">true</span><span>
</span>    };
<!-- -->  };
<!-- -->}
<!-- -->
</code></pre>
<p>在组件中使用如下:</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#d08770">@Input</span><span>() </span><span style="color:#d08770">@WithConfig</span><span>() nzSize: NzSizeLDSType | </span><span style="color:#d08770">number</span><span> = </span><span style="color:#a3be8c">&#x27;default&#x27;</span><span>;
</span>
</code></pre>
<p>如何保证优先级?</p>
<p>组件调用&gt;用户配置&gt;默认配置</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#b48ead">const</span><span> assignedByUser = (</span><span style="color:#d08770">this</span><span>.propertyAssignCounter?.[propName] || </span><span style="color:#d08770">0</span><span>) &gt; </span><span style="color:#d08770">1</span><span>;
</span>
</code></pre>
<p>每次调用set的时候会+1，大于1说明用户自己设置了，使用用户设置的值，否则先读配置里，没有的话再读组件里的默认值。</p>
</li>
</ol>
<h2 id="使用,[object Object],对浮层进行统一管理"><a href="#使用,[object Object],对浮层进行统一管理" class="mr-2">#</a>使用<a href="https://v12.material.angular.io/cdk/overlay/overview">angular/cdk/overlay</a>对浮层进行统一管理</h2>
<p>为什么需要对浮层进行统一管理？</p>
<ul>
<li>规避父元素样式的影响（比如transition属性的影响）</li>
<li>在创建和销毁弹出层时，避免影响应用主体</li>
<li>方便 z-index 的设置与管理</li>
</ul>
<p>@angular/cdk的overlay模块提供了一套管理浮层的功能</p>
<p>使用大致如下：</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#b48ead">const</span><span> containerPortal = </span><span style="color:#b48ead">new</span><span> ComponentPortal&lt;BaseModalContainerComponent&gt;(
</span>      ContainerComponent,
<!-- -->      config.nzViewContainerRef,
<!-- -->      injector
<!-- -->    );
<span></span><span style="color:#b48ead">const</span><span> containerRef = overlayRef.attach&lt;BaseModalContainerComponent&gt;(containerPortal);
</span>
</code></pre><div class="styles_catalogue-container__i6Zhk"><div class="styles_skeleton-container__qbEBJ"><div class="styles_skeleton__p5JvS" data-level="2"></div><div class="styles_skeleton__p5JvS" data-level="2"></div><div class="styles_skeleton__p5JvS" data-level="2"></div><div class="styles_skeleton__p5JvS" data-level="2"></div><div class="styles_skeleton__p5JvS" data-level="2"></div><div class="styles_skeleton__p5JvS" data-level="2"></div></div><nav class="styles_navigation__NkDRt"><ul><li class="" data-level="2"><a href="#目录">目录</a></li><li class="" data-level="2"><a href="#ONPUSH变更检测模式的使用">ONPUSH变更检测模式的使用</a></li><li class="" data-level="2"><a href="#使用">使用</a></li><li class="" data-level="2"><a href="#对templateRef传参的处理">对templateRef传参的处理</a></li><li class="" data-level="2"><a href="#对装饰器的使用">对装饰器的使用</a></li><li class="" data-level="2"><a href="#使用对浮层进行统一管理">使用对浮层进行统一管理</a></li></ul></nav></div></div><div class="content-container"></div></main><footer class="grid place-items-center pb-4"><a href="https://github.com/hmilin" target="_blank" rel="noreferrer noopener">😘Github</a></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    ol: \"ol\",\n    li: \"li\",\n    ul: \"ul\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Ng-Zorro代码鉴赏\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"目录\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \"| 文件/文件名称 | 说明 | \\n| components | 组件文件夹，包含框架组件源码 |\\n| docs | 非组件文章文档，如国际化、全局配置等 |\\n| integration | 构建操作工具，搭配 travis 使用 |\\n| schematics | 自定义脚手架，ng g add ng-zorro-antd |\\n| scripts | 发布/调试脚本 |\\n| CODE_OF_CONDUCT.md | 贡献指南 |\\n| CHANGELOG.md | 发布日志 |\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"其中components/core 放了一些公共代码\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"关于和ant-design保持样式统一，他们使用了\", _jsx(_components.a, {\n        href: \"https://github.com/ng-zorro-bot\",\n        children: \"机器人\"\n      }), \"从ant-design同步样式代码。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"ONPUSH变更检测模式的使用\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"angular中有两种检测模式，一种是CheckAlways，一种是CheckOnce，通过component装饰器的changeDetection字段来定义\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"@Component({\\n  changeDetection: ChangeDetectionStrategy.OnPush\\n})\\nexport declare enum ChangeDetectionStrategy {\\n    /**\\n     * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\\n     * until reactivated by setting the strategy to `Default` (`CheckAlways`).\\n     * Change detection can still be explicitly invoked.\\n     * This strategy applies to all child directives and cannot be overridden.\\n     */\\n    OnPush = 0,\\n    /**\\n     * Use the default `CheckAlways` strategy, in which change detection is automatic until\\n     * explicitly deactivated.\\n     */\\n    Default = 1\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"OnPush模式的使用:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"由\", _jsx(_components.a, {\n        href: \"https://angular.cn/api/core/ChangeDetectorRef\",\n        children: \"ChangeDetectorRef\"\n      }), \"提供变更检测功能\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"abstract class ChangeDetectorRef {\\n  abstract markForCheck(): void // 当视图使用 OnPush（checkOnce）变更检测策略时，把该视图显式标记为已更改，以便它再次进行检查。\\n  abstract detach(): void // 从变更检测树中分离开视图。 \\n  abstract detectChanges(): void // 检查该视图及其子视图。\\n  abstract checkNoChanges(): void // 检查变更检测器及其子检测器，如果检测到任何更改，则抛出异常。\\n  abstract reattach(): void // 把以前分离开的视图重新附加到变更检测树上。 视图会被默认附加到这棵树上。\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"使用示例：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"zorro中这段代码出现过很多次，作用是当全局配置中对应当前组件的配置修改时，将视图标记为需检测。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"this.nzConfigService\\n    .getConfigChangeEventForComponent(NZ_CONFIG_COMPONENT_NAME)\\n    .pipe(takeUntil(this.destroy$))\\n    .subscribe(() =\u003e {\\n    this.cdr.markForCheck();\\n});\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"表单控件中，当writeVaule执行时（即将变化的数据写入视图时），标记为需检测。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"writeValue(value: number): void {\\n    this.value = value;\\n    this.setValue(value);\\n    this.updateDisplayValue(value);\\n    this.cdr.markForCheck();\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"使用\", _jsx(_components.a, {\n        href: \"https://angular.cn/api/core/NgZone\",\n        children: \"NgZone\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Zone 是跨异步任务而持久存在的执行上下文。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ngZone基于zone.js，是Angular变更检测的基础，Angular通过zone监听到了异步任务的执行过程，便于在异步任务执行时触发变更检测。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"使用\", _jsx(_components.code, {\n        children: \"ngZone.runOutsideAngular\"\n      }), \"让代码执行不触发新的变更检测，在调用\", _jsx(_components.code, {\n        children: \"run\"\n      }), \"将这些任务重新进入Angular zone\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"this.ngZone.runOutsideAngular(() =\u003e {\\n      fromEvent\u003cMouseEvent\u003e(this.elementRef.nativeElement, 'click')\\n        .pipe(takeUntil(this.destroy$))\\n        .subscribe(event =\u003e {\\n          /** prevent label click triggered twice. **/\\n          event.stopPropagation();\\n          event.preventDefault();\\n          if (this.nzDisabled || this.isChecked) {\\n            return;\\n          }\\n          this.ngZone.run(() =\u003e {\\n            if (this.nzRadioService) {\\n              this.nzRadioService.select(this.nzValue);\\n            }\\n            if (this.isNgModel) {\\n              this.isChecked = true;\\n              this.onChange(true);\\n            }\\n            this.cdr.markForCheck();\\n          });\\n        });\\n    });\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"对templateRef传参的处理\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Zorro的组件中很多支持\", _jsx(_components.code, {\n        children: \"string | TemplateRef\u003cvoid\u003e\"\n      }), \"这种类型的传参，用于将字符串或模板植入组件视图。angular有一个\", _jsx(_components.a, {\n        href: \"https://angular.cn/api/common/NgTemplateOutlet\",\n        children: \"NgTemplateOutlet\"\n      }), \"指令，用于将templateRef插入视图，为了同时处理TemplateRef和string类型，zorro中封装了一个类似的指令\", _jsx(_components.code, {\n        children: \"nzStringTemplateOutlet\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"核心代码为\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"constructor(private viewContainer: ViewContainerRef, private templateRef: TemplateRef\u003cNzSafeAny\u003e) {}\\n\\nprivate recreateView(): void {\\n    this.viewContainer.clear();\\n    const isTemplateRef = this.nzStringTemplateOutlet instanceof TemplateRef;\\n    const templateRef = (isTemplateRef ? this.nzStringTemplateOutlet : this.templateRef) as NzSafeAny;\\n    this.embeddedViewRef = this.viewContainer.createEmbeddedView(\\n    templateRef,\\n    isTemplateRef ? this.nzStringTemplateOutletContext : this.context\\n    );\\n}\\n  \\nngOnChanges(changes: SimpleChanges): void {\\n    // ...\\n     if (recreateView) {\\n      /** recreate view when context shape or outlet change **/\\n      this.recreateView();\\n    } else {\\n    // ...\\n\\t}\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在很多个组件文件里都能看到他的使用，大概如下:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"\u003cng-container *nzStringTemplateOutlet=\\\"nzMessage\\\"\u003e{{ nzMessage }}\u003c/ng-container\u003e\\n@Input() nzMessage: string | TemplateRef\u003cvoid\u003e | null = null;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"指令是Angular中用于封装公共行为的强有力工具，它拥有了对模板的控制权，和组件一样拥有生命周期，但是使用起来更灵活。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"对装饰器的使用\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"属性装饰器\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"zorro中基本每一个组件都会看到@InputNumber、@InputBoolean这样的装饰器使用，用于对输入参数进行强制类型转换，避免因类型错误影响后面程序运行。\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"在typescript中声明一个工厂装饰器的思路大致如下：\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-typescript\",\n            children: \"function name () {\\n    return function(target: IConfirmableDirective, propertyKey: string, descriptor: PropertyDescriptor) {\\n            // TODO 对装饰对象的处理，并返回新的descriptor\\n    }\\n}\\n\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"zorro中定义了一个生产属性装饰器的函数，传入装饰器名称和对属性的处理函数，即可生成一个装饰器。\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-typescript\",\n            children: \"function propDecoratorFactory\u003cT, D\u003e(\\n  name: string,\\n  fallback: (v: T) =\u003e D\\n): (target: NzSafeAny, propName: string) =\u003e void {\\n  function propDecorator(\\n    target: NzSafeAny,\\n    propName: string,\\n    originalDescriptor?: TypedPropertyDescriptor\u003cNzSafeAny\u003e\\n  ): NzSafeAny {\\n    const privatePropName = `$$__zorroPropDecorator__${propName}`;\\n\\n    if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {\\n      warn(`The prop \\\"${privatePropName}\\\" is already exist, it will be overrided by ${name} decorator.`);\\n    }\\n\\n    Object.defineProperty(target, privatePropName, {\\n      configurable: true,\\n      writable: true\\n    });\\n\\n    return {\\n      get(): string {\\n        return originalDescriptor \u0026\u0026 originalDescriptor.get\\n          ? originalDescriptor.get.bind(this)()\\n          : this[privatePropName];\\n      },\\n      set(value: T): void {\\n        if (originalDescriptor \u0026\u0026 originalDescriptor.set) {\\n          originalDescriptor.set.bind(this)(fallback(value));\\n        }\\n        this[privatePropName] = fallback(value);\\n      }\\n    };\\n  }\\n\\n  return propDecorator;\\n}\\n\\nexport function InputBoolean(): NzSafeAny {\\n  return propDecoratorFactory('InputBoolean', toBoolean);\\n}\\n\\n\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"从全局配置中获取默认数值的装饰器\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"zorro提供了一个\", _jsx(_components.code, {\n            children: \"NzConfigService\"\n          }), \"类，可以通过依赖注入的方式或者调用api的方式来设置组件的默认配置\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-typescript\",\n            children: \"export function WithConfig\u003cT\u003e() {\\n  return function ConfigDecorator(\\n    target: NzSafeAny,\\n    propName: NzSafeAny,\\n    originalDescriptor?: TypedPropertyDescriptor\u003cT\u003e\\n  ): NzSafeAny {\\n    const privatePropName = `$$__zorroConfigDecorator__${propName}`;\\n\\n    Object.defineProperty(target, privatePropName, {\\n      configurable: true,\\n      writable: true,\\n      enumerable: false\\n    });\\n\\n    return {\\n      get(): T | undefined {\\n        const originalValue = originalDescriptor?.get ? originalDescriptor.get.bind(this)() : this[privatePropName];\\n        const assignedByUser = (this.propertyAssignCounter?.[propName] || 0) \u003e 1;\\n        const configValue = this.nzConfigService.getConfigForComponent(this._nzModuleName)?.[propName];\\n        if (assignedByUser \u0026\u0026 isDefined(originalValue)) {\\n          return originalValue;\\n        } else {\\n          return isDefined(configValue) ? configValue : originalValue;\\n        }\\n      },\\n      set(value?: T): void {\\n        // If the value is assigned, we consider the newly assigned value as 'assigned by user'.\\n        this.propertyAssignCounter = this.propertyAssignCounter || {};\\n        this.propertyAssignCounter[propName] = (this.propertyAssignCounter[propName] || 0) + 1;\\n\\n        if (originalDescriptor?.set) {\\n          originalDescriptor.set.bind(this)(value!);\\n        } else {\\n          this[privatePropName] = value;\\n        }\\n      },\\n      configurable: true,\\n      enumerable: true\\n    };\\n  };\\n}\\n\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"在组件中使用如下:\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-typescript\",\n            children: \"@Input() @WithConfig() nzSize: NzSizeLDSType | number = 'default';\\n\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"如何保证优先级?\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"组件调用\u003e用户配置\u003e默认配置\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-typescript\",\n            children: \"const assignedByUser = (this.propertyAssignCounter?.[propName] || 0) \u003e 1;\\n\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"每次调用set的时候会+1，大于1说明用户自己设置了，使用用户设置的值，否则先读配置里，没有的话再读组件里的默认值。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"使用\", _jsx(_components.a, {\n        href: \"https://v12.material.angular.io/cdk/overlay/overview\",\n        children: \"angular/cdk/overlay\"\n      }), \"对浮层进行统一管理\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"为什么需要对浮层进行统一管理？\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"规避父元素样式的影响（比如transition属性的影响）\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"在创建和销毁弹出层时，避免影响应用主体\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"方便 z-index 的设置与管理\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"@angular/cdk的overlay模块提供了一套管理浮层的功能\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"使用大致如下：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"const containerPortal = new ComponentPortal\u003cBaseModalContainerComponent\u003e(\\n      ContainerComponent,\\n      config.nzViewContainerRef,\\n      injector\\n    );\\nconst containerRef = overlayRef.attach\u003cBaseModalContainerComponent\u003e(containerPortal);\\n\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"Ng-Zorro代码鉴赏","date":"2021-12-10 13:55:00","description":"Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。","category":"framework"}},"frontMatter":{"title":"Ng-Zorro代码鉴赏","date":"2021-12-10 13:55:00","description":"Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。","category":"framework"},"headings":[{"depth":2,"text":"目录"},{"depth":2,"text":"ONPUSH变更检测模式的使用"},{"depth":2,"text":"使用"},{"depth":2,"text":"对templateRef传参的处理"},{"depth":2,"text":"对装饰器的使用"},{"depth":2,"text":"使用对浮层进行统一管理"}]},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"ng-zorro-study"},"buildId":"dFrmMN50ll23FrSW9hL6z","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>