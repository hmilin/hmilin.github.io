<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>蛋黄派碎冰冰</title><meta name="description" content="蛋黄派碎冰冰的博客"/><link rel="icon" href="/favicon.ico"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/ab184196c72fe85b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab184196c72fe85b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/4a0c5542377ce400.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4a0c5542377ce400.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-1d2bf428d878d876.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-e267bb9839e5051c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-fe85ddc63867fc19.js" defer=""></script><script src="/_next/static/chunks/347-34557e8e6f4e11a0.js" defer=""></script><script src="/_next/static/chunks/966-c28dfefcc6bfc2ef.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-31076c76e5eeee58.js" defer=""></script><script src="/_next/static/UCxDjeWqw3tY68elYXU5x/_buildManifest.js" defer=""></script><script src="/_next/static/UCxDjeWqw3tY68elYXU5x/_ssgManifest.js" defer=""></script><script src="/_next/static/UCxDjeWqw3tY68elYXU5x/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="Layout_container__CSAqU"><header class="Header_header__Z4YN5"><a href="/">蛋黄派碎冰冰</a><nav><ul><li><a href="/#posts">文章</a></li><li><a href="/about">关于</a></li></ul></nav></header><main><div class="Layout_banner__0qsJd"><h1>Git commit 修改</h1><p>Git Rebase的使用。</p><div>2021-03-13 20:53:00</div></div><div class="content-container"><p>工作过程中经常遇到已经开发好的功能有一些小变动，一个小功能多次提交看着总是不太舒服，需要使用cherry-pick的时也不方便。</p>
<h3>往上一个提交追加内容</h3>
<p>使用 git commit --amend  即可</p>
<h3>修改某一个历史提交</h3>
<p>找到该提交的上一个commitId，执行</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span>git rebase &lt;commitId&gt; --interactive
</span></code></pre>
<p>在vi中将pick改为edit，执行 git add ,然后 git commit --amend，最后执行 git rebase --continue</p>
<h3>将多个commit合并为一个</h3>
<p>Step 1.  git rebase -i   commit-id    会合并此次提交之后所有的提交为一个提交， 注意此次提交不会包含在内。</p>
<p>Step 2.  在 vim 编辑器中 会列出所有要合并的提交， 并修改内容,  保存并推出vim。
           pick  commit-id-1  commit-msg-1   =&gt;  pick  commit-id-1  commit-msg-1
           pick commit-id-2  commit-msg-2   =&gt;  s commit-id-2  commit-msg-2
           pick commit-id-3  commit-msg-3  =&gt;   s commit-id-3  commit-msg-3</p>
<p>step 3.  如果有冲突发生，解决冲突后并git add 然后运行  git rebase --continue,  在弹出的vim编辑器重重新编辑提交message. 
            然后保存并退出。 如果要终止这次合并 git rebase --abort ,  git rebase --edit-todo 重新查看和编辑。</p>
<p>Step 4. 如果远程仓库有当前分支，则可能会让我们进行git pull 操作， 此时执行 git push origin :branch-name  删除远程分支， 
           git branch --unset-upstream  将本地分支和远程分支进行解除关联。</p>
<p>Step 5. 最后运行 git push --set-upstream origin branch-name,  将本地合并的提交推送到远程仓库。 </p>
<ul>
<li>
<p>pick：简写p，表示启用该commitId</p>
</li>
<li>
<p>reword：简写r，使用该comitId，但是修改提交信息，修改后可以继续编辑后面的提交信息</p>
</li>
<li>
<p>edit：简写e，使用该commitId，停止合并该commitId</p>
</li>
<li>
<p>squash：简写s，使用该commitId，并将该commitId并入前一个commitId</p>
</li>
<li>
<p>drop：简写d，移除该commitId</p>
</li>
</ul></div><div class="content-container"></div></main><footer class="grid place-items-center pb-4"><a href="https://github.com/hmilin" target="_blank" rel="noreferrer noopener">😘Github</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      h3: \"h3\",\n      pre: \"pre\",\n      code: \"code\",\n      ul: \"ul\",\n      li: \"li\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"工作过程中经常遇到已经开发好的功能有一些小变动，一个小功能多次提交看着总是不太舒服，需要使用cherry-pick的时也不方便。\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"往上一个提交追加内容\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"使用 git commit --amend  即可\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"修改某一个历史提交\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"找到该提交的上一个commitId，执行\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"git rebase \u003ccommitId\u003e --interactive\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"在vi中将pick改为edit，执行 git add ,然后 git commit --amend，最后执行 git rebase --continue\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"将多个commit合并为一个\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Step 1.  git rebase -i   commit-id    会合并此次提交之后所有的提交为一个提交， 注意此次提交不会包含在内。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Step 2.  在 vim 编辑器中 会列出所有要合并的提交， 并修改内容,  保存并推出vim。\\n           pick  commit-id-1  commit-msg-1   =\u003e  pick  commit-id-1  commit-msg-1\\n           pick commit-id-2  commit-msg-2   =\u003e  s commit-id-2  commit-msg-2\\n           pick commit-id-3  commit-msg-3  =\u003e   s commit-id-3  commit-msg-3\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"step 3.  如果有冲突发生，解决冲突后并git add 然后运行  git rebase --continue,  在弹出的vim编辑器重重新编辑提交message. \\n            然后保存并退出。 如果要终止这次合并 git rebase --abort ,  git rebase --edit-todo 重新查看和编辑。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Step 4. 如果远程仓库有当前分支，则可能会让我们进行git pull 操作， 此时执行 git push origin :branch-name  删除远程分支， \\n           git branch --unset-upstream  将本地分支和远程分支进行解除关联。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Step 5. 最后运行 git push --set-upstream origin branch-name,  将本地合并的提交推送到远程仓库。 \"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"pick：简写p，表示启用该commitId\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"reword：简写r，使用该comitId，但是修改提交信息，修改后可以继续编辑后面的提交信息\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"edit：简写e，使用该commitId，停止合并该commitId\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"squash：简写s，使用该commitId，并将该commitId并入前一个commitId\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"drop：简写d，移除该commitId\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"Git commit 修改","date":"2021-03-13 20:53:00","description":"Git Rebase的使用。"}},"frontMatter":{"title":"Git commit 修改","date":"2021-03-13 20:53:00","description":"Git Rebase的使用。"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"git-rebase"},"buildId":"UCxDjeWqw3tY68elYXU5x","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>