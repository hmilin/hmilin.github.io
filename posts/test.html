<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>蛋黄派碎冰冰</title><meta name="description" content="蛋黄派碎冰冰的博客"/><link rel="icon" href="/favicon.ico"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/ab184196c72fe85b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab184196c72fe85b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/4a0c5542377ce400.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4a0c5542377ce400.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-1d2bf428d878d876.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-e267bb9839e5051c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-fe85ddc63867fc19.js" defer=""></script><script src="/_next/static/chunks/347-34557e8e6f4e11a0.js" defer=""></script><script src="/_next/static/chunks/966-c28dfefcc6bfc2ef.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-31076c76e5eeee58.js" defer=""></script><script src="/_next/static/UCxDjeWqw3tY68elYXU5x/_buildManifest.js" defer=""></script><script src="/_next/static/UCxDjeWqw3tY68elYXU5x/_ssgManifest.js" defer=""></script><script src="/_next/static/UCxDjeWqw3tY68elYXU5x/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="Layout_container__CSAqU"><header class="Header_header__Z4YN5"><a href="/">蛋黄派碎冰冰</a><nav><ul><li><a href="/#posts">文章</a></li><li><a href="/about">关于</a></li></ul></nav></header><main><div class="Layout_banner__0qsJd"><h1>测试学习笔记</h1><p>测试理论记录和实践。</p><div>2022-11-25 16:55:43</div></div><div class="content-container"><h1>测试学习笔记</h1>
<h2>理论学习</h2>
<h3>几个原则</h3>
<ol>
<li>使用AAA模式构造测试内容：Arrange(准备)  Act(执行) Assert(断言)</li>
<li>代码尽量简单，使用通用的断言方法</li>
<li>只测试公共方法</li>
<li>正确使用测试替身（主要是理清楚测试目的）</li>
<li>利用库(如faker.js)造一些真实数据进行测试，可以更早发现问题</li>
<li>使用快照时，使用短的行内快照</li>
<li>尽量避免使用全局初始化数据，每个测试中自己初始化需要的数据</li>
<li>不要catch错误，expect它们</li>
<li>给测试用例打tag，用于筛选目标用例实行，具体要看测试库如何实现</li>
</ol>
<h3>前端测试</h3>
<ol>
<li>将UI和功能分离，避免因为渲染复杂的UI拖慢测试速度</li>
<li>使用不容易改变的属性查询HTML，tag或者专属属性如test-id，而不是css选择器</li>
<li>有条件下完全渲染组件进行测试，如果其中一个子组件明显拖慢测试(如动画)或使很难配置，可以考虑主动用伪组件替换它</li>
<li>避免使用sleep，使用库允许的等待操作，如cypress.request(&#x27;url&#x27;)，testin-library的wait(expect(element))</li>
<li>观察内容如何通过网络提供：<!-- -->
<ol>
<li>使用一些活动监视器，以确保在真实网络下的页面负载是最优的</li>
<li>使用前端工具 (如 <a href="https://developers.google.com/web/tools/lighthouse/">lighthouse</a>、<a href="https://developers.google.com/speed/pagespeed/insights/">pagespeed</a>) 以进行更全面的分析</li>
</ol>
</li>
<li>非E2E测试时，避免使用真实后端API，使用替身库代替</li>
<li>写几个跨越整个系统的E2E测试，1-10个</li>
<li>通过复用登录凭证提速 E2E 测试</li>
<li>创建一个E2E冒烟测试，该测试跑一遍所有页面，可以避免因为打包问题有些页面没办法正常渲染</li>
</ol>
<h2>项目实践</h2>
<h2>参考链接</h2>
<p><a href="https://github.com/goldbergyoni/javascript-testing-best-practices">https://github.com/goldbergyoni/javascript-testing-best-practices</a></p></div><div class="content-container"></div></main><footer class="grid place-items-center pb-4"><a href="https://github.com/hmilin" target="_blank" rel="noreferrer noopener">😘Github</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h1: \"h1\",\n      h2: \"h2\",\n      h3: \"h3\",\n      ol: \"ol\",\n      li: \"li\",\n      a: \"a\",\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h1, {\n        children: \"测试学习笔记\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"理论学习\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"几个原则\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"使用AAA模式构造测试内容：Arrange(准备)  Act(执行) Assert(断言)\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"代码尽量简单，使用通用的断言方法\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"只测试公共方法\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"正确使用测试替身（主要是理清楚测试目的）\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"利用库(如faker.js)造一些真实数据进行测试，可以更早发现问题\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"使用快照时，使用短的行内快照\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"尽量避免使用全局初始化数据，每个测试中自己初始化需要的数据\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"不要catch错误，expect它们\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"给测试用例打tag，用于筛选目标用例实行，具体要看测试库如何实现\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"前端测试\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"将UI和功能分离，避免因为渲染复杂的UI拖慢测试速度\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"使用不容易改变的属性查询HTML，tag或者专属属性如test-id，而不是css选择器\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"有条件下完全渲染组件进行测试，如果其中一个子组件明显拖慢测试(如动画)或使很难配置，可以考虑主动用伪组件替换它\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"避免使用sleep，使用库允许的等待操作，如cypress.request('url')，testin-library的wait(expect(element))\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"观察内容如何通过网络提供：\", \"\\n\", _jsxs(_components.ol, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"使用一些活动监视器，以确保在真实网络下的页面负载是最优的\"\n            }), \"\\n\", _jsxs(_components.li, {\n              children: [\"使用前端工具 (如 \", _jsx(_components.a, {\n                href: \"https://developers.google.com/web/tools/lighthouse/\",\n                children: \"lighthouse\"\n              }), \"、\", _jsx(_components.a, {\n                href: \"https://developers.google.com/speed/pagespeed/insights/\",\n                children: \"pagespeed\"\n              }), \") 以进行更全面的分析\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"非E2E测试时，避免使用真实后端API，使用替身库代替\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"写几个跨越整个系统的E2E测试，1-10个\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"通过复用登录凭证提速 E2E 测试\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"创建一个E2E冒烟测试，该测试跑一遍所有页面，可以避免因为打包问题有些页面没办法正常渲染\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"项目实践\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"参考链接\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/goldbergyoni/javascript-testing-best-practices\",\n          children: \"https://github.com/goldbergyoni/javascript-testing-best-practices\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"测试学习笔记","date":"2022-11-25 16:55:43","description":"测试理论记录和实践。","public":false}},"frontMatter":{"title":"测试学习笔记","date":"2022-11-25 16:55:43","description":"测试理论记录和实践。","public":false}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"test"},"buildId":"UCxDjeWqw3tY68elYXU5x","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>