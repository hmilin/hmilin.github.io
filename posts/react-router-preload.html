<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Meiling&#x27;s Blog</title><meta name="description" content="meiling的博客"/><link rel="icon" href="/favicon.ico"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/56ac636d8286ddc4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/56ac636d8286ddc4.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a85178c7df1bcd20.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a85178c7df1bcd20.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-c50d706355616eef.js" defer=""></script><script src="/_next/static/chunks/framework-a85322f027b40e20.js" defer=""></script><script src="/_next/static/chunks/main-95aa3232ca423ead.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c28c633855fb2140.js" defer=""></script><script src="/_next/static/chunks/495-31a10f133dd42cb0.js" defer=""></script><script src="/_next/static/chunks/785-afa51abc884a1702.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-aa35ebeedcc516ae.js" defer=""></script><script src="/_next/static/OKE3GmY2jrZso7TnNn3Ue/_buildManifest.js" defer=""></script><script src="/_next/static/OKE3GmY2jrZso7TnNn3Ue/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_container__XDtoS"><header class="Header_header__aO32P"><div class="Header_mobileNav__x8dOm"><div class="Header_menuIcon__zsaJW"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M120-240v-80h720v80zm0-200v-80h720v80zm0-200v-80h720v80z"></path></svg></div><a class="Header_searchBtn__DiCC5" href="/search"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580t75.5-184.5T380-840t184.5 75.5T640-580q0 44-14 83t-38 69l252 252zM380-400q75 0 127.5-52.5T560-580t-52.5-127.5T380-760t-127.5 52.5T200-580t52.5 127.5T380-400"></path></svg></a></div><nav class="Header_nav__wk8Zc"><div class="Header_closeIcon__TBNuf"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224z"></path></svg></div><a class="Header_searchBtn__DiCC5" href="/search"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580t75.5-184.5T380-840t184.5 75.5T640-580q0 44-14 83t-38 69l252 252zM380-400q75 0 127.5-52.5T560-580t-52.5-127.5T380-760t-127.5 52.5T200-580t52.5 127.5T380-400"></path></svg></a><a class="" href="/"><div class="Header_icon__SYetk"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M200-160v-366L88-440l-48-64 440-336 160 122v-82h120v174l160 122-48 64-112-86v366H520v-240h-80v240zm80-80h80v-240h240v240h80v-347L480-739 280-587zm120-319h160q0-32-24-52.5T480-632t-56 20.5-24 52.5m-40 319v-240h240v240-240H360z"></path></svg></div><div class="Header_title__BTC6R">首页</div></a><a class="" href="/category/native"><div class="Header_icon__SYetk"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M200-640v440h560v-440H640v320l-160-80-160 80v-320zm0 520q-33 0-56.5-23.5T120-200v-499q0-14 4.5-27t13.5-24l50-61q11-14 27.5-21.5T250-840h460q18 0 34.5 7.5T772-811l50 61q9 11 13.5 24t4.5 27v499q0 33-23.5 56.5T760-120zm16-600h528l-34-40H250zm184 80v190l80-40 80 40v-190zm-200 0h560z"></path></svg></div><div class="Header_title__BTC6R">原生基础</div></a><a class="" href="/category/framework"><div class="Header_icon__SYetk"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M400-400h160v-80H400zm0-120h320v-80H400zm0-120h320v-80H400zm-80 400q-33 0-56.5-23.5T240-320v-480q0-33 23.5-56.5T320-880h480q33 0 56.5 23.5T880-800v480q0 33-23.5 56.5T800-240zm0-80h480v-480H320zM160-80q-33 0-56.5-23.5T80-160v-560h80v560h560v80zm160-720v480z"></path></svg></div><div class="Header_title__BTC6R">框架相关</div></a><a class="" href="/category/tool"><div class="Header_icon__SYetk"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="m620-284 56-56q6-6 6-14t-6-14L540-505q4-11 6-22t2-25q0-57-40.5-97.5T410-690q-17 0-34 4.5T343-673l94 94-56 56-94-94q-8 16-12.5 33t-4.5 34q0 57 40.5 97.5T408-412q13 0 24.5-2t22.5-6l137 136q6 6 14 6t14-6M480-80q-83 0-156-31.5T197-197t-85.5-127T80-480t31.5-156T197-763t127-85.5T480-880t156 31.5T763-763t85.5 127T880-480t-31.5 156T763-197t-127 85.5T480-80m0-80q134 0 227-93t93-227-93-227-227-93-227 93-93 227 93 227 227 93m0-320"></path></svg></div><div class="Header_title__BTC6R">工具使用</div></a><a class="" href="/category/performance"><div class="Header_icon__SYetk"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M220-520 80-600v-160l140-80 140 80v160zm0-92 60-34v-68l-60-34-60 34v68zm440 123v-93l140 82v280L560-80 320-220v-280l140-82v93l-60 35v188l160 93 160-93v-188zm-140 89v-480h360l-80 120 80 120H600v240zM220-680"></path></svg></div><div class="Header_title__BTC6R">性能提升</div></a><a class="" href="/about"><div class="Header_icon__SYetk"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#5f6368" viewBox="0 -960 960 960"><path d="M360-390q-21 0-35.5-14.5T310-440t14.5-35.5T360-490t35.5 14.5T410-440t-14.5 35.5T360-390m240 0q-21 0-35.5-14.5T550-440t14.5-35.5T600-490t35.5 14.5T650-440t-14.5 35.5T600-390M480-160q134 0 227-93t93-227q0-24-3-46.5T786-570q-21 5-42 7.5t-44 2.5q-91 0-172-39T390-708q-32 78-91.5 135.5T160-486v6q0 134 93 227t227 93m0 80q-83 0-156-31.5T197-197t-85.5-127T80-480t31.5-156T197-763t127-85.5T480-880t156 31.5T763-763t85.5 127T880-480t-31.5 156T763-197t-127 85.5T480-80m-54-715q42 70 114 112.5T700-640q14 0 27-1.5t27-3.5q-42-70-114-112.5T480-800q-14 0-27 1.5t-27 3.5M177-581q51-29 89-75t57-103q-51 29-89 75t-57 103m146-178"></path></svg></div><div class="Header_title__BTC6R">关于</div></a></nav></header><div><main><div class="Layout_cover__vC5GW"><div><h1>React中的预加载策略</h1><p>React路由框架的预加载策略对比，以及在使用react-router时如何进行预加载设置</p><div>2024-08-26 10:13:00</div></div></div><div class="content-container"><h1 id="React中的预加载策略"><a href="#React中的预加载策略" class="mr-2">#</a>React中的预加载策略</h1>
<p>在现代前端项目中，构建工具会根据文件间导入的关系和用户的自定义策略进行分包，并结合组件懒加载和动态导入等函数声明，让页面在到达指定路由下，再加载相应的文件。
进行路由预加载设置主要有两个好处：</p>
<ol>
<li>提升页面加载性能。用户首次进入页面时，只加载必要的文件，可提升首屏的加载速度，主要对LCP的时间有明显提升。</li>
<li>提升稳定性。当应用版本更新后，静态文件的hash值可能发生变化，原来的文件可能获取不到，当用户在应用版本更新前打开页面，当路由跳转时是不会重新获取静态文件地址列表，这时页面可能会因为找不到文件而无法继续使用，用户只能通过刷新页面来解决。</li>
</ol>
<h2 id="link标签的prefetch和preload模式"><a href="#link标签的prefetch和preload模式" class="mr-2">#</a>link标签的prefetch和preload模式</h2>
<p>在原生html文件中，link标签用于加载外部资源，理解link标签对资源加载时机的设计，可以帮助我们理解路由预加载策略的设计思路。在使用link标签来加载文件时，rel参数的<code>prefetch</code>和<code>preload</code>模式都是和懒加载相关的参数，他们的区别如下：</p>
<p>prefetch: 用于预获取下一个页面需要的文件，请求的优先级一般为Lowest</p>
<p>preload: 用于加载当前页面很快就需要的文件，在页面生命周期开始之前就会触发请求，当加载js文件时，请求优先级为High，加载css文件时优先级为Highest</p>
<h2 id="React路由框架的预加载策略对比"><a href="#React路由框架的预加载策略对比" class="mr-2">#</a>React路由框架的预加载策略对比</h2>
<ol>
<li>ReactRouter</li>
</ol>
<p>没有对预加载的实现，需要使用者自定义</p>
<ol start="2">
<li>Nextjs</li>
</ol>
<p>在Link组件上通过<code>prefetch</code>传参来定义是否开启预加载，设置为<code>true</code>时，当link组件渲染在可视范围内，开始预加载相关文件，这种预加载模式比较接近原生<link/>的prefetch模式。</p>
<ol start="3">
<li>
<p>TanStack Router</p>
</li>
<li>
<p>可全局设置默认预加载策略，也可基于Link个性化</p>
</li>
<li>
<p>目前已提供了两种预加载策略：<code>intent</code>和<code>viewport</code> ，前者会在hover到<code>Link</code>组件时加载组件，后者跟Nextjs的方案相似，在<code>Link</code>组件进入视图中加载组件</p>
</li>
</ol>
<h2 id="使用ReactRouter如何自定义预加载策略"><a href="#使用ReactRouter如何自定义预加载策略" class="mr-2">#</a>使用ReactRouter如何自定义预加载策略</h2>
<h3 id="基本思路"><a href="#基本思路" class="mr-2">#</a>基本思路</h3>
<ol>
<li>扩展<code>react-router</code>的<code>Link</code>组件，增加preload参数，支持<code>&#x27;intent&#x27;</code>和<code>&#x27;viewport&#x27;</code>两种策略。</li>
<li>定义一个<code>lazyLoad</code>函数替换<code>React.lazy</code>，返回对象中增加<code>preload</code>方法，用于手动调用。</li>
<li>在声明route配置时声明Component参数为：<code>lazyLoad(() =&gt; import(&#x27;@src/pages/xxx&#x27;))</code>。</li>
<li>Link组件中根据传入的<code>to</code>拿到相应的<code>Component</code>之后即可调用步骤2声明的preload方法，并根据指定的策略来决定调用的时机。</li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="mr-2">#</a>具体实现</h3>
<p><code>Link</code>组件:</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#b48ead">import</span><span> useForkRef </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;@/hooks/useForkRef&#x27;</span><span>;
</span><span></span><span style="color:#b48ead">import</span><span> { useIntersectionObserver } </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;@/hooks/useIntersectionObserver&#x27;</span><span>;
</span><span></span><span style="color:#b48ead">import</span><span> </span><span style="color:#b48ead">type</span><span> { ComponentType } </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;react&#x27;</span><span>;
</span><span></span><span style="color:#b48ead">import</span><span> { forwardRef, useCallback, useRef } </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;react&#x27;</span><span>;
</span><span></span><span style="color:#b48ead">import</span><span> </span><span style="color:#b48ead">type</span><span> { LinkProps </span><span style="color:#b48ead">as</span><span> RouterLinkProps } </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;react-router-dom&#x27;</span><span>;
</span><span></span><span style="color:#b48ead">import</span><span> { Link </span><span style="color:#b48ead">as</span><span> RouterLink, matchRoutes } </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;react-router-dom&#x27;</span><span>;
</span><span></span><span style="color:#b48ead">import</span><span> useRoutesData </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;../RoutesProvider/useRoutesData&#x27;</span><span>;
</span><span></span><span style="color:#b48ead">import</span><span> </span><span style="color:#b48ead">type</span><span> { LazyLoadResult } </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;@/utils/lazy&#x27;</span><span>;
</span>
<span></span><span style="color:#b48ead">interface</span><span> LinkProps </span><span style="color:#b48ead">extends</span><span> RouterLinkProps {
</span><span>  </span><span style="color:#65737e">/** preload strategy */</span><span>
</span><span>  preload?: </span><span style="color:#a3be8c">&#x27;intent&#x27;</span><span> | </span><span style="color:#a3be8c">&#x27;viewport&#x27;</span><span> | </span><span style="color:#d08770">false</span><span>;
</span>}
<!-- -->
<span></span><span style="color:#65737e">/**
</span><span class="hljs-function" style="color:#d08770"> * 基于react-router-dom的Link组件实现了preload功能
</span><span style="color:#65737e"> */</span><span>
</span><span></span><span style="color:#b48ead">const</span><span> Link = forwardRef&lt;HTMLAnchorElement, LinkProps&gt;(</span><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">Link</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#d08770">
</span><span class="hljs-function" style="color:#d08770">  { preload, onMouseEnter, ...props },
</span><span class="hljs-function" style="color:#d08770">  forwardedRef,
</span><span class="hljs-function" style="color:#d08770"></span><span class="hljs-function">) </span><span>{
</span><span>  </span><span style="color:#b48ead">const</span><span> preloadedComponent = useRef&lt;ComponentType&gt;();
</span><span>  </span><span style="color:#b48ead">const</span><span> elementRef = useRef&lt;HTMLAnchorElement | </span><span style="color:#d08770">null</span><span>&gt;(</span><span style="color:#d08770">null</span><span>);
</span><span>  </span><span style="color:#b48ead">const</span><span> mergedRef = useForkRef(elementRef, forwardedRef);
</span>
<span>  </span><span style="color:#65737e">// 拿到所有routes配置</span><span>
</span><span>  </span><span style="color:#b48ead">const</span><span> routes = useRoutesData();
</span>
<span>  </span><span style="color:#65737e">// preload component</span><span>
</span><span>  </span><span style="color:#b48ead">const</span><span> preloadComponent = useCallback(</span><span class="hljs-function">() =&gt;</span><span> {
</span><span>    </span><span style="color:#b48ead">if</span><span> (!preloadedComponent.current) {
</span><span>      </span><span style="color:#b48ead">const</span><span> matches = matchRoutes(routes, props.to);
</span><span>      matches?.forEach(</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#d08770">route</span><span class="hljs-function">) =&gt;</span><span> {
</span><span>        </span><span style="color:#b48ead">const</span><span> loader = (route.route.Component </span><span style="color:#b48ead">as</span><span> LazyLoadResult)?.preload;
</span><span>        </span><span style="color:#b48ead">if</span><span> (loader) {
</span><span>          loader().then(</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#d08770">module</span><span class="hljs-function">) =&gt;</span><span> {
</span><span>            preloadedComponent.current = </span><span style="color:#d08770">module</span><span>.default;
</span>          });
<!-- -->        }
<!-- -->      });
<!-- -->    }
<!-- -->  }, [props.to, routes]);
<!-- -->
<span>  </span><span style="color:#b48ead">const</span><span> handleMouseEnter: React.MouseEventHandler&lt;HTMLAnchorElement&gt; = useCallback(
</span><span>    </span><span class="hljs-function">(</span><span class="hljs-function" style="color:#d08770">e</span><span class="hljs-function">) =&gt;</span><span> {
</span><span>      </span><span style="color:#b48ead">if</span><span> (preload === </span><span style="color:#a3be8c">&#x27;intent&#x27;</span><span>) {
</span>        preloadComponent();
<!-- -->      }
<!-- -->      onMouseEnter?.(e);
<!-- -->    },
<!-- -->    [preloadComponent, onMouseEnter, preload],
<!-- -->  );
<!-- -->
<span>  </span><span style="color:#b48ead">const</span><span> preloadViewportIoCallback = useCallback(
</span><span>    </span><span class="hljs-function">(</span><span class="hljs-function" style="color:#d08770">entry: IntersectionObserverEntry | </span><span class="hljs-function" style="color:#d08770">undefined</span><span class="hljs-function">) =&gt;</span><span> {
</span><span>      </span><span style="color:#b48ead">if</span><span> (entry?.isIntersecting) {
</span>        preloadComponent();
<!-- -->      }
<!-- -->    },
<!-- -->    [preloadComponent],
<!-- -->  );
<!-- -->
<!-- -->  useIntersectionObserver&lt;HTMLAnchorElement&gt;(
<!-- -->    elementRef,
<!-- -->    preloadViewportIoCallback,
<!-- -->    {},
<span>    { </span><span class="hljs-attr">disabled</span><span>: preload !== </span><span style="color:#a3be8c">&#x27;viewport&#x27;</span><span> },
</span>  );
<!-- -->
<span>  </span><span style="color:#b48ead">return</span><span> </span><span class="xml" style="color:#bf616a">&lt;</span><span class="xml" style="color:#bf616a">RouterLink</span><span class="xml" style="color:#bf616a"> </span><span class="xml hljs-attr" style="color:#bf616a">ref</span><span class="xml" style="color:#bf616a">=</span><span class="xml" style="color:#a3be8c">{mergedRef}</span><span class="xml" style="color:#bf616a"> {</span><span class="xml hljs-attr" style="color:#bf616a">...props</span><span class="xml" style="color:#bf616a">} </span><span class="xml hljs-attr" style="color:#bf616a">onMouseEnter</span><span class="xml" style="color:#bf616a">=</span><span class="xml" style="color:#a3be8c">{handleMouseEnter}</span><span class="xml" style="color:#bf616a"> /&gt;</span><span>;
</span>});
<!-- -->
<span></span><span style="color:#b48ead">export</span><span> </span><span style="color:#b48ead">default</span><span> Link;
</span></code></pre>
<p><code>lazyLoad</code>函数：</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#b48ead">import</span><span> </span><span style="color:#b48ead">type</span><span> { ComponentType, LazyExoticComponent } </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;react&#x27;</span><span>;
</span><span></span><span style="color:#b48ead">import</span><span> { lazy } </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;react&#x27;</span><span>;
</span>
<span></span><span style="color:#b48ead">export</span><span> </span><span style="color:#b48ead">type</span><span> LazyLoadResult&lt;T </span><span style="color:#b48ead">extends</span><span> ComponentType&lt;</span><span style="color:#d08770">any</span><span>&gt; = ComponentType&lt;</span><span style="color:#d08770">any</span><span>&gt;&gt; =
</span>  LazyExoticComponent&lt;T&gt; &amp; {
<span>    </span><span class="hljs-attr">preload</span><span>: </span><span class="hljs-function">() =&gt;</span><span> </span><span style="color:#d08770">Promise</span><span>&lt;{ </span><span class="hljs-attr">default</span><span>: T }&gt;;
</span>  };
<!-- -->
<span></span><span style="color:#b48ead">export</span><span> </span><span class="hljs-function" style="color:#b48ead">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">lazyLoad</span><span class="hljs-function">&lt;</span><span class="hljs-function" style="color:#8fa1b3">T</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">extends</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#8fa1b3">ComponentType</span><span class="hljs-function">&lt;</span><span class="hljs-function" style="color:#8fa1b3">any</span><span class="hljs-function">&gt;&gt;(</span><span class="hljs-function" style="color:#d08770">
</span><span class="hljs-function" style="color:#d08770">  load: () =&gt; </span><span class="hljs-function" style="color:#d08770">Promise</span><span class="hljs-function" style="color:#d08770">&lt;{ </span><span class="hljs-function" style="color:#b48ead">default</span><span class="hljs-function" style="color:#d08770">: T }&gt;,
</span><span class="hljs-function" style="color:#d08770"></span><span class="hljs-function">): </span><span class="hljs-function" style="color:#8fa1b3">LazyLoadResult</span><span class="hljs-function">&lt;</span><span class="hljs-function" style="color:#8fa1b3">T</span><span class="hljs-function">&gt; </span><span>{
</span><span>  </span><span style="color:#b48ead">let</span><span> preloaded = </span><span style="color:#d08770">false</span><span>;
</span><span>  </span><span style="color:#b48ead">let</span><span> loadedComponent: { </span><span class="hljs-attr">default</span><span>: T };
</span><span>  </span><span style="color:#b48ead">const</span><span> loadComponent = </span><span style="color:#b48ead">async</span><span> () =&gt; {
</span><span>    </span><span style="color:#b48ead">if</span><span> (preloaded) </span><span style="color:#b48ead">return</span><span> loadedComponent;
</span><span>    loadedComponent = </span><span style="color:#b48ead">await</span><span> load().then(</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#d08770">res</span><span class="hljs-function">) =&gt;</span><span> {
</span><span>      preloaded = </span><span style="color:#d08770">true</span><span>;
</span><span>      </span><span style="color:#b48ead">return</span><span> res;
</span>    });
<span>    </span><span style="color:#b48ead">return</span><span> loadedComponent;
</span>  };
<span>  </span><span style="color:#b48ead">const</span><span> preload = loadComponent;
</span><span>  </span><span style="color:#b48ead">const</span><span> lazyComponent: </span><span style="color:#d08770">any</span><span> = lazy(loadComponent);
</span>  lazyComponent.preload = preload;
<!-- -->
<span>  </span><span style="color:#b48ead">return</span><span> lazyComponent </span><span style="color:#b48ead">as</span><span> LazyLoadResult&lt;T&gt;;
</span>}
</code></pre>
<p><code>routes</code>文件:</p>
<pre style="display:block;overflow-x:auto;background:#2b303b;color:#c0c5ce;padding:0.5em"><code class="block-code" style="white-space:pre"><span style="color:#b48ead">import</span><span> Loading </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;@/components/Loading&#x27;</span><span>;
</span><span></span><span style="color:#b48ead">import</span><span> Layout </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;@/components/layouts&#x27;</span><span>;
</span><span></span><span style="color:#b48ead">import</span><span> { lazyLoad } </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;@/utils/lazy&#x27;</span><span>;
</span><span></span><span style="color:#b48ead">import</span><span> </span><span style="color:#b48ead">type</span><span> { RouteObject } </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;react-router-dom&#x27;</span><span>;
</span><span></span><span style="color:#b48ead">import</span><span> { Navigate } </span><span style="color:#b48ead">from</span><span> </span><span style="color:#a3be8c">&#x27;react-router-dom&#x27;</span><span>;
</span>
<span></span><span style="color:#b48ead">const</span><span> Home = lazyLoad(</span><span class="hljs-function">() =&gt;</span><span> </span><span style="color:#b48ead">import</span><span>(</span><span style="color:#a3be8c">&#x27;@/pages/Home&#x27;</span><span>));
</span><span></span><span style="color:#b48ead">const</span><span> routes: RouteObject[] = [
</span>  {
<span>    </span><span class="hljs-attr">path</span><span>: </span><span style="color:#a3be8c">&#x27;/&#x27;</span><span>,
</span><span>    </span><span class="hljs-attr">element</span><span>: </span><span class="xml" style="color:#bf616a">&lt;</span><span class="xml" style="color:#bf616a">Layout</span><span class="xml" style="color:#bf616a"> /&gt;</span><span>,
</span>    children: [
<!-- -->      {
<span>        </span><span class="hljs-attr">index</span><span>: </span><span style="color:#d08770">true</span><span>,
</span><span>        </span><span class="hljs-attr">element</span><span>: </span><span class="xml" style="color:#bf616a">&lt;</span><span class="xml" style="color:#bf616a">Navigate</span><span class="xml" style="color:#bf616a"> </span><span class="xml hljs-attr" style="color:#bf616a">to</span><span class="xml" style="color:#bf616a">=</span><span class="xml" style="color:#a3be8c">&quot;/home&quot;</span><span class="xml" style="color:#bf616a"> /&gt;</span><span>,
</span>      },
<!-- -->      {
<span>        </span><span class="hljs-attr">path</span><span>: </span><span style="color:#a3be8c">&#x27;home&#x27;</span><span>,
</span><span>        </span><span class="hljs-attr">Component</span><span>: Home,
</span>      },
<!-- -->    ],
<!-- -->  },
<!-- -->];
<!-- -->
<span></span><span style="color:#b48ead">export</span><span> </span><span style="color:#b48ead">default</span><span> routes;
</span></code></pre>
<p>具体代码实现可参考模板项目：<a href="https://github.com/hmilin/react-vite-template">hmilin/react-vite-template</a></p>
<h2 id="为什么插件,[object Object],对加载性能提升无效"><a href="#为什么插件,[object Object],对加载性能提升无效" class="mr-2">#</a>为什么插件<code>vite-plugin-preload</code>对加载性能提升无效</h2>
<p>在<code>vite+react</code>项目中解决预加载问题时，看到插件<code>vite-plugin-preload</code>，但是看了他的具体实现方式发现并不能解决我们的问题。原因是：使用<code>vite-plugin-preload</code>插件后，所有原先动态加载的模块都会使用<code>&lt;link rel=&quot;modulepreload&quot; href=&quot;xxx.js&quot; /&gt;</code>加到入口html文件中，这意味着用户首次打开页面时，将在第一时间加载所有模块文件，且请求优先级为High。当项目比较庞大时，首屏加载时间将会变得很大。</p><div class="styles_catalogue-container__i6Zhk"><div class="styles_skeleton-container__qbEBJ"><div class="styles_skeleton__p5JvS" data-level="2"></div><div class="styles_skeleton__p5JvS" data-level="2"></div><div class="styles_skeleton__p5JvS" data-level="2"></div><div class="styles_skeleton__p5JvS" data-level="3"></div><div class="styles_skeleton__p5JvS" data-level="3"></div><div class="styles_skeleton__p5JvS" data-level="2"></div></div><nav class="styles_navigation__NkDRt"><ul><li class="" data-level="2"><a href="#link标签的prefetch和preload模式">link标签的prefetch和preload模式</a></li><li class="" data-level="2"><a href="#React路由框架的预加载策略对比">React路由框架的预加载策略对比</a></li><li class="" data-level="2"><a href="#使用ReactRouter如何自定义预加载策略">使用ReactRouter如何自定义预加载策略</a></li><li class="" data-level="3"><a href="#基本思路">基本思路</a></li><li class="" data-level="3"><a href="#具体实现">具体实现</a></li><li class="" data-level="2"><a href="#为什么插件对加载性能提升无效">为什么插件对加载性能提升无效</a></li></ul></nav></div></div><div class="content-container"></div></main><footer class="grid place-items-center pb-4"><a href="https://github.com/hmilin" target="_blank" rel="noreferrer noopener">😘Github</a></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    h2: \"h2\",\n    code: \"code\",\n    h3: \"h3\",\n    pre: \"pre\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"React中的预加载策略\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在现代前端项目中，构建工具会根据文件间导入的关系和用户的自定义策略进行分包，并结合组件懒加载和动态导入等函数声明，让页面在到达指定路由下，再加载相应的文件。\\n进行路由预加载设置主要有两个好处：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"提升页面加载性能。用户首次进入页面时，只加载必要的文件，可提升首屏的加载速度，主要对LCP的时间有明显提升。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"提升稳定性。当应用版本更新后，静态文件的hash值可能发生变化，原来的文件可能获取不到，当用户在应用版本更新前打开页面，当路由跳转时是不会重新获取静态文件地址列表，这时页面可能会因为找不到文件而无法继续使用，用户只能通过刷新页面来解决。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"link标签的prefetch和preload模式\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在原生html文件中，link标签用于加载外部资源，理解link标签对资源加载时机的设计，可以帮助我们理解路由预加载策略的设计思路。在使用link标签来加载文件时，rel参数的\", _jsx(_components.code, {\n        children: \"prefetch\"\n      }), \"和\", _jsx(_components.code, {\n        children: \"preload\"\n      }), \"模式都是和懒加载相关的参数，他们的区别如下：\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"prefetch: 用于预获取下一个页面需要的文件，请求的优先级一般为Lowest\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"preload: 用于加载当前页面很快就需要的文件，在页面生命周期开始之前就会触发请求，当加载js文件时，请求优先级为High，加载css文件时优先级为Highest\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"React路由框架的预加载策略对比\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"ReactRouter\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"没有对预加载的实现，需要使用者自定义\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Nextjs\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在Link组件上通过\", _jsx(_components.code, {\n        children: \"prefetch\"\n      }), \"传参来定义是否开启预加载，设置为\", _jsx(_components.code, {\n        children: \"true\"\n      }), \"时，当link组件渲染在可视范围内，开始预加载相关文件，这种预加载模式比较接近原生\", _jsx(\"link\", {}), \"的prefetch模式。\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"TanStack Router\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"可全局设置默认预加载策略，也可基于Link个性化\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"目前已提供了两种预加载策略：\", _jsx(_components.code, {\n            children: \"intent\"\n          }), \"和\", _jsx(_components.code, {\n            children: \"viewport\"\n          }), \" ，前者会在hover到\", _jsx(_components.code, {\n            children: \"Link\"\n          }), \"组件时加载组件，后者跟Nextjs的方案相似，在\", _jsx(_components.code, {\n            children: \"Link\"\n          }), \"组件进入视图中加载组件\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"使用ReactRouter如何自定义预加载策略\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"基本思路\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"扩展\", _jsx(_components.code, {\n          children: \"react-router\"\n        }), \"的\", _jsx(_components.code, {\n          children: \"Link\"\n        }), \"组件，增加preload参数，支持\", _jsx(_components.code, {\n          children: \"'intent'\"\n        }), \"和\", _jsx(_components.code, {\n          children: \"'viewport'\"\n        }), \"两种策略。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"定义一个\", _jsx(_components.code, {\n          children: \"lazyLoad\"\n        }), \"函数替换\", _jsx(_components.code, {\n          children: \"React.lazy\"\n        }), \"，返回对象中增加\", _jsx(_components.code, {\n          children: \"preload\"\n        }), \"方法，用于手动调用。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"在声明route配置时声明Component参数为：\", _jsx(_components.code, {\n          children: \"lazyLoad(() =\u003e import('@src/pages/xxx'))\"\n        }), \"。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Link组件中根据传入的\", _jsx(_components.code, {\n          children: \"to\"\n        }), \"拿到相应的\", _jsx(_components.code, {\n          children: \"Component\"\n        }), \"之后即可调用步骤2声明的preload方法，并根据指定的策略来决定调用的时机。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"具体实现\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Link\"\n      }), \"组件:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import useForkRef from '@/hooks/useForkRef';\\nimport { useIntersectionObserver } from '@/hooks/useIntersectionObserver';\\nimport type { ComponentType } from 'react';\\nimport { forwardRef, useCallback, useRef } from 'react';\\nimport type { LinkProps as RouterLinkProps } from 'react-router-dom';\\nimport { Link as RouterLink, matchRoutes } from 'react-router-dom';\\nimport useRoutesData from '../RoutesProvider/useRoutesData';\\nimport type { LazyLoadResult } from '@/utils/lazy';\\n\\ninterface LinkProps extends RouterLinkProps {\\n  /** preload strategy */\\n  preload?: 'intent' | 'viewport' | false;\\n}\\n\\n/**\\n * 基于react-router-dom的Link组件实现了preload功能\\n */\\nconst Link = forwardRef\u003cHTMLAnchorElement, LinkProps\u003e(function Link(\\n  { preload, onMouseEnter, ...props },\\n  forwardedRef,\\n) {\\n  const preloadedComponent = useRef\u003cComponentType\u003e();\\n  const elementRef = useRef\u003cHTMLAnchorElement | null\u003e(null);\\n  const mergedRef = useForkRef(elementRef, forwardedRef);\\n\\n  // 拿到所有routes配置\\n  const routes = useRoutesData();\\n\\n  // preload component\\n  const preloadComponent = useCallback(() =\u003e {\\n    if (!preloadedComponent.current) {\\n      const matches = matchRoutes(routes, props.to);\\n      matches?.forEach((route) =\u003e {\\n        const loader = (route.route.Component as LazyLoadResult)?.preload;\\n        if (loader) {\\n          loader().then((module) =\u003e {\\n            preloadedComponent.current = module.default;\\n          });\\n        }\\n      });\\n    }\\n  }, [props.to, routes]);\\n\\n  const handleMouseEnter: React.MouseEventHandler\u003cHTMLAnchorElement\u003e = useCallback(\\n    (e) =\u003e {\\n      if (preload === 'intent') {\\n        preloadComponent();\\n      }\\n      onMouseEnter?.(e);\\n    },\\n    [preloadComponent, onMouseEnter, preload],\\n  );\\n\\n  const preloadViewportIoCallback = useCallback(\\n    (entry: IntersectionObserverEntry | undefined) =\u003e {\\n      if (entry?.isIntersecting) {\\n        preloadComponent();\\n      }\\n    },\\n    [preloadComponent],\\n  );\\n\\n  useIntersectionObserver\u003cHTMLAnchorElement\u003e(\\n    elementRef,\\n    preloadViewportIoCallback,\\n    {},\\n    { disabled: preload !== 'viewport' },\\n  );\\n\\n  return \u003cRouterLink ref={mergedRef} {...props} onMouseEnter={handleMouseEnter} /\u003e;\\n});\\n\\nexport default Link;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"lazyLoad\"\n      }), \"函数：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import type { ComponentType, LazyExoticComponent } from 'react';\\nimport { lazy } from 'react';\\n\\nexport type LazyLoadResult\u003cT extends ComponentType\u003cany\u003e = ComponentType\u003cany\u003e\u003e =\\n  LazyExoticComponent\u003cT\u003e \u0026 {\\n    preload: () =\u003e Promise\u003c{ default: T }\u003e;\\n  };\\n\\nexport function lazyLoad\u003cT extends ComponentType\u003cany\u003e\u003e(\\n  load: () =\u003e Promise\u003c{ default: T }\u003e,\\n): LazyLoadResult\u003cT\u003e {\\n  let preloaded = false;\\n  let loadedComponent: { default: T };\\n  const loadComponent = async () =\u003e {\\n    if (preloaded) return loadedComponent;\\n    loadedComponent = await load().then((res) =\u003e {\\n      preloaded = true;\\n      return res;\\n    });\\n    return loadedComponent;\\n  };\\n  const preload = loadComponent;\\n  const lazyComponent: any = lazy(loadComponent);\\n  lazyComponent.preload = preload;\\n\\n  return lazyComponent as LazyLoadResult\u003cT\u003e;\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"routes\"\n      }), \"文件:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import Loading from '@/components/Loading';\\nimport Layout from '@/components/layouts';\\nimport { lazyLoad } from '@/utils/lazy';\\nimport type { RouteObject } from 'react-router-dom';\\nimport { Navigate } from 'react-router-dom';\\n\\nconst Home = lazyLoad(() =\u003e import('@/pages/Home'));\\nconst routes: RouteObject[] = [\\n  {\\n    path: '/',\\n    element: \u003cLayout /\u003e,\\n    children: [\\n      {\\n        index: true,\\n        element: \u003cNavigate to=\\\"/home\\\" /\u003e,\\n      },\\n      {\\n        path: 'home',\\n        Component: Home,\\n      },\\n    ],\\n  },\\n];\\n\\nexport default routes;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"具体代码实现可参考模板项目：\", _jsx(_components.a, {\n        href: \"https://github.com/hmilin/react-vite-template\",\n        children: \"hmilin/react-vite-template\"\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"为什么插件\", _jsx(_components.code, {\n        children: \"vite-plugin-preload\"\n      }), \"对加载性能提升无效\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在\", _jsx(_components.code, {\n        children: \"vite+react\"\n      }), \"项目中解决预加载问题时，看到插件\", _jsx(_components.code, {\n        children: \"vite-plugin-preload\"\n      }), \"，但是看了他的具体实现方式发现并不能解决我们的问题。原因是：使用\", _jsx(_components.code, {\n        children: \"vite-plugin-preload\"\n      }), \"插件后，所有原先动态加载的模块都会使用\", _jsx(_components.code, {\n        children: \"\u003clink rel=\\\"modulepreload\\\" href=\\\"xxx.js\\\" /\u003e\"\n      }), \"加到入口html文件中，这意味着用户首次打开页面时，将在第一时间加载所有模块文件，且请求优先级为High。当项目比较庞大时，首屏加载时间将会变得很大。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"React中的预加载策略","description":"React路由框架的预加载策略对比，以及在使用react-router时如何进行预加载设置","public":true,"date":"2024-08-26 10:13:00","category":"performance"}},"frontMatter":{"title":"React中的预加载策略","description":"React路由框架的预加载策略对比，以及在使用react-router时如何进行预加载设置","public":true,"date":"2024-08-26 10:13:00","category":"performance"},"headings":[{"depth":2,"text":"link标签的prefetch和preload模式"},{"depth":2,"text":"React路由框架的预加载策略对比"},{"depth":2,"text":"使用ReactRouter如何自定义预加载策略"},{"depth":3,"text":"基本思路"},{"depth":3,"text":"具体实现"},{"depth":2,"text":"为什么插件对加载性能提升无效"}]},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"react-router-preload"},"buildId":"OKE3GmY2jrZso7TnNn3Ue","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>