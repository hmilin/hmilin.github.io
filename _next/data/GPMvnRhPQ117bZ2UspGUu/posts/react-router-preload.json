{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    h2: \"h2\",\n    code: \"code\",\n    h3: \"h3\",\n    pre: \"pre\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"React中的预加载策略\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在现代前端项目中，构建工具会根据文件间导入的关系和用户的自定义策略进行分包，并结合组件懒加载和动态导入等函数声明，让页面在到达指定路由下，再加载相应的文件。\\n进行路由预加载设置主要有两个好处：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"提升页面加载性能。用户首次进入页面时，只加载必要的文件，可提升首屏的加载速度，主要对LCP的时间有明显提升。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"提升稳定性。当应用版本更新后，静态文件的hash值可能发生变化，原来的文件可能获取不到，当用户在应用版本更新前打开页面，当路由跳转时是不会重新获取静态文件地址列表，这时页面可能会因为找不到文件而无法继续使用，用户只能通过刷新页面来解决。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"link标签的prefetch和preload模式\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在原生html文件中，link标签用于加载外部资源，理解link标签对资源加载时机的设计，可以帮助我们理解路由预加载策略的设计思路。在使用link标签来加载文件时，rel参数的\", _jsx(_components.code, {\n        children: \"prefetch\"\n      }), \"和\", _jsx(_components.code, {\n        children: \"preload\"\n      }), \"模式都是和懒加载相关的参数，他们的区别如下：\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"prefetch: 用于预获取下一个页面需要的文件，请求的优先级一般为Lowest\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"preload: 用于加载当前页面很快就需要的文件，在页面生命周期开始之前就会触发请求，当加载js文件时，请求优先级为High，加载css文件时优先级为Highest\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"React路由框架的预加载策略对比\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"ReactRouter\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"没有对预加载的实现，需要使用者自定义\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Nextjs\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在Link组件上通过\", _jsx(_components.code, {\n        children: \"prefetch\"\n      }), \"传参来定义是否开启预加载，设置为\", _jsx(_components.code, {\n        children: \"true\"\n      }), \"时，当link组件渲染在可视范围内，开始预加载相关文件，这种预加载模式比较接近原生\", _jsx(\"link\", {}), \"的prefetch模式。\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"TanStack Router\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"可全局设置默认预加载策略，也可基于Link个性化\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"目前已提供了两种预加载策略：\", _jsx(_components.code, {\n            children: \"intent\"\n          }), \"和\", _jsx(_components.code, {\n            children: \"viewport\"\n          }), \" ，前者会在hover到\", _jsx(_components.code, {\n            children: \"Link\"\n          }), \"组件时加载组件，后者跟Nextjs的方案相似，在\", _jsx(_components.code, {\n            children: \"Link\"\n          }), \"组件进入视图中加载组件\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"使用ReactRouter如何自定义预加载策略\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"基本思路\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"扩展\", _jsx(_components.code, {\n          children: \"react-router\"\n        }), \"的\", _jsx(_components.code, {\n          children: \"Link\"\n        }), \"组件，增加preload参数，支持\", _jsx(_components.code, {\n          children: \"'intent'\"\n        }), \"和\", _jsx(_components.code, {\n          children: \"'viewport'\"\n        }), \"两种策略。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"定义一个\", _jsx(_components.code, {\n          children: \"lazyLoad\"\n        }), \"函数替换\", _jsx(_components.code, {\n          children: \"React.lazy\"\n        }), \"，返回对象中增加\", _jsx(_components.code, {\n          children: \"preload\"\n        }), \"方法，用于手动调用。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"在声明route配置时声明Component参数为：\", _jsx(_components.code, {\n          children: \"lazyLoad(() => import('@src/pages/xxx'))\"\n        }), \"。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Link组件中根据传入的\", _jsx(_components.code, {\n          children: \"to\"\n        }), \"拿到相应的\", _jsx(_components.code, {\n          children: \"Component\"\n        }), \"之后即可调用步骤2声明的preload方法，并根据指定的策略来决定调用的时机。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"具体实现\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Link\"\n      }), \"组件:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import useForkRef from '@/hooks/useForkRef';\\nimport { useIntersectionObserver } from '@/hooks/useIntersectionObserver';\\nimport type { ComponentType } from 'react';\\nimport { forwardRef, useCallback, useRef } from 'react';\\nimport type { LinkProps as RouterLinkProps } from 'react-router-dom';\\nimport { Link as RouterLink, matchRoutes } from 'react-router-dom';\\nimport useRoutesData from '../RoutesProvider/useRoutesData';\\nimport type { LazyLoadResult } from '@/utils/lazy';\\n\\ninterface LinkProps extends RouterLinkProps {\\n  /** preload strategy */\\n  preload?: 'intent' | 'viewport' | false;\\n}\\n\\n/**\\n * 基于react-router-dom的Link组件实现了preload功能\\n */\\nconst Link = forwardRef<HTMLAnchorElement, LinkProps>(function Link(\\n  { preload, onMouseEnter, ...props },\\n  forwardedRef,\\n) {\\n  const preloadedComponent = useRef<ComponentType>();\\n  const elementRef = useRef<HTMLAnchorElement | null>(null);\\n  const mergedRef = useForkRef(elementRef, forwardedRef);\\n\\n  // 拿到所有routes配置\\n  const routes = useRoutesData();\\n\\n  // preload component\\n  const preloadComponent = useCallback(() => {\\n    if (!preloadedComponent.current) {\\n      const matches = matchRoutes(routes, props.to);\\n      matches?.forEach((route) => {\\n        const loader = (route.route.Component as LazyLoadResult)?.preload;\\n        if (loader) {\\n          loader().then((module) => {\\n            preloadedComponent.current = module.default;\\n          });\\n        }\\n      });\\n    }\\n  }, [props.to, routes]);\\n\\n  const handleMouseEnter: React.MouseEventHandler<HTMLAnchorElement> = useCallback(\\n    (e) => {\\n      if (preload === 'intent') {\\n        preloadComponent();\\n      }\\n      onMouseEnter?.(e);\\n    },\\n    [preloadComponent, onMouseEnter, preload],\\n  );\\n\\n  const preloadViewportIoCallback = useCallback(\\n    (entry: IntersectionObserverEntry | undefined) => {\\n      if (entry?.isIntersecting) {\\n        preloadComponent();\\n      }\\n    },\\n    [preloadComponent],\\n  );\\n\\n  useIntersectionObserver<HTMLAnchorElement>(\\n    elementRef,\\n    preloadViewportIoCallback,\\n    {},\\n    { disabled: preload !== 'viewport' },\\n  );\\n\\n  return <RouterLink ref={mergedRef} {...props} onMouseEnter={handleMouseEnter} />;\\n});\\n\\nexport default Link;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"lazyLoad\"\n      }), \"函数：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import type { ComponentType, LazyExoticComponent } from 'react';\\nimport { lazy } from 'react';\\n\\nexport type LazyLoadResult<T extends ComponentType<any> = ComponentType<any>> =\\n  LazyExoticComponent<T> & {\\n    preload: () => Promise<{ default: T }>;\\n  };\\n\\nexport function lazyLoad<T extends ComponentType<any>>(\\n  load: () => Promise<{ default: T }>,\\n): LazyLoadResult<T> {\\n  let preloaded = false;\\n  let loadedComponent: { default: T };\\n  const loadComponent = async () => {\\n    if (preloaded) return loadedComponent;\\n    loadedComponent = await load().then((res) => {\\n      preloaded = true;\\n      return res;\\n    });\\n    return loadedComponent;\\n  };\\n  const preload = loadComponent;\\n  const lazyComponent: any = lazy(loadComponent);\\n  lazyComponent.preload = preload;\\n\\n  return lazyComponent as LazyLoadResult<T>;\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"routes\"\n      }), \"文件:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import Loading from '@/components/Loading';\\nimport Layout from '@/components/layouts';\\nimport { lazyLoad } from '@/utils/lazy';\\nimport type { RouteObject } from 'react-router-dom';\\nimport { Navigate } from 'react-router-dom';\\n\\nconst Home = lazyLoad(() => import('@/pages/Home'));\\nconst routes: RouteObject[] = [\\n  {\\n    path: '/',\\n    element: <Layout />,\\n    children: [\\n      {\\n        index: true,\\n        element: <Navigate to=\\\"/home\\\" />,\\n      },\\n      {\\n        path: 'home',\\n        Component: Home,\\n      },\\n    ],\\n  },\\n];\\n\\nexport default routes;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"具体代码实现可参考模板项目：\", _jsx(_components.a, {\n        href: \"https://github.com/hmilin/react-vite-template\",\n        children: \"hmilin/react-vite-template\"\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"为什么插件\", _jsx(_components.code, {\n        children: \"vite-plugin-preload\"\n      }), \"对加载性能提升无效\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在\", _jsx(_components.code, {\n        children: \"vite+react\"\n      }), \"项目中解决预加载问题时，看到插件\", _jsx(_components.code, {\n        children: \"vite-plugin-preload\"\n      }), \"，但是看了他的具体实现方式发现并不能解决我们的问题。原因是：使用\", _jsx(_components.code, {\n        children: \"vite-plugin-preload\"\n      }), \"插件后，所有原先动态加载的模块都会使用\", _jsx(_components.code, {\n        children: \"<link rel=\\\"modulepreload\\\" href=\\\"xxx.js\\\" />\"\n      }), \"加到入口html文件中，这意味着用户首次打开页面时，将在第一时间加载所有模块文件，且请求优先级为High。当项目比较庞大时，首屏加载时间将会变得很大。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"React中的预加载策略","description":"React路由框架的预加载策略对比，以及在使用react-router时如何进行预加载设置","public":true,"date":"2024-08-26 10:13:00","category":"performance"}},"frontMatter":{"title":"React中的预加载策略","description":"React路由框架的预加载策略对比，以及在使用react-router时如何进行预加载设置","public":true,"date":"2024-08-26 10:13:00","category":"performance"}},"__N_SSG":true}