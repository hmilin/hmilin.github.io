{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    h2: \"h2\",\n    p: \"p\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"单页面应用如何处理版本更新\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"新旧版本同时运行\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"为保证用户体验，应该确保在部署新版本后，用户在旧版本环境下应该能正常使用，不能因版本更新而中断了流程。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"打开页面后预加载所有文件\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"确保旧版本文件能正常获取\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"加载异常文件时自动导航到新版本（兜底）\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"通知用户更新\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"利用Service Worker预加载新版本并通知\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"轮询或在理由跳转时查看是否有新版本\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"单页面应用如何处理版本更新","description":"页面应用在部署新版本到生产环境后，如何兼容旧版本运行，并通知用户。","public":false,"date":"2024-08-28 18:26:00","category":"performance"}},"frontMatter":{"title":"单页面应用如何处理版本更新","description":"页面应用在部署新版本到生产环境后，如何兼容旧版本运行，并通知用户。","public":false,"date":"2024-08-28 18:26:00","category":"performance"}},"__N_SSG":true}