{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    a: \"a\",\n    h2: \"h2\",\n    pre: \"pre\",\n    h3: \"h3\",\n    img: \"img\",\n    h4: \"h4\",\n    h5: \"h5\",\n    ol: \"ol\",\n    li: \"li\",\n    ul: \"ul\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"前端兼容问题主要以语言划分有\", _jsx(_components.code, {\n        children: \"JavaScript\"\n      }), \"和\", _jsx(_components.code, {\n        children: \"CSS\"\n      }), \"两类，其中\", _jsx(_components.code, {\n        children: \"JavaScript\"\n      }), \"分为语法和功能特性，语法的兼容一般通过编译工具来做语法转换，功能特性可以通过引入\", _jsx(_components.code, {\n        children: \"Polyfills\"\n      }), \"来兼容低版本浏览器。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"对于不同的新提案，浏览器不同版本的实现先后顺序不一致，可以从\", _jsx(_components.a, {\n        href: \"https://caniuse.com/\",\n        children: \"caniuse\"\n      }), \"查到数据。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"设定兼容目标\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在\", _jsx(_components.code, {\n        children: \"package.json\"\n      }), \"中声明\", _jsx(_components.code, {\n        children: \"browserslist\"\n      }), \"是受大部分工具认可和使用的标准，借助\", _jsx(_components.code, {\n        children: \"browserslist\"\n      }), \"来统一读取兼容标准，并从\", _jsx(_components.code, {\n        children: \"caniuse-lite\"\n      }), \"中读到兼容性数据。\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"{\\n\\\"browserslist\\\": [\\n    \\\"Chrome >=80\\\",\\n    \\\"Firefox >=72\\\",\\n    \\\"Safari >=13.1\\\",\\n    \\\"Edge >=80\\\"\\n  ]\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"如何在开发时检测兼容性问题\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"依赖于测试和用户反馈兼容性问题显然是不被允许的，要求开发人员记住所有特性的兼容性显然也不符合实际，所以应该借助插件，在开发过程中及时检测到问题。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"ESLint\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"使用ESLint的\", _jsx(_components.code, {\n        children: \"eslint-plugin-compat\"\n      }), \"识别出js中的兼容性\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"安装依赖之后在eslintrc.js中配置\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"module.exports = {\\n  plugins: ['compat'],\\n  extends: ['plugin:compat/recommended'],\\n  env: {\\n    browser: true,\\n  },\\n};\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"插件会读取package.json中的browserslist\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"当调用\", _jsx(_components.code, {\n        children: \"new PaymentRequest()\"\n      }), \"的时候，eslint会给出以下提示\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/posts-img/eslint-compat-1.png\",\n        alt: \"PaymentRequest\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"注意：这个插件的兼容规则没有很完整，像\", _jsx(_components.code, {\n        children: \"Promise.any\"\n      }), \"  \", _jsx(_components.code, {\n        children: \"Array.property.at\"\n      }), \"等方法没有定义检测规则\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"StyleLint\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"使用\", _jsx(_components.code, {\n        children: \"stylelint-no-unsupported-browser-features\"\n      }), \"插件\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"注意：StyleLint 15到16之间有一个重大变更是CommonJS到ESM的迁移，\", _jsx(_components.code, {\n        children: \"stylelint-no-unsupported-browser-features\"\n      }), \"插件的最新版本是使用ESM的，根据\", _jsx(_components.code, {\n        children: \"npm view stylelint-no-unsupported-browser-features@[Version] peerDependencies\"\n      }), \"来选择合适的版本\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"{\\n  customSyntax: postLess,\\n  plugins: [..., 'stylelint-no-unsupported-browser-features'],\\n  rules: {\\n    ...,\\n    \\\"plugin/no-unsupported-browser-features\\\": [true, {\\n      \\\"browsers\\\": [\\n        \\\"Chrome >=80\\\",\\n        \\\"Firefox >=72\\\",\\n        \\\"Safari >=13.1\\\",\\n        \\\"Edge >=80\\\"\\n      ],\\n      \\\"ignore\\\": [\\\"css-nesting\\\"],\\n      \\\"ignorePartialSupport\\\": true\\n    }]\\n  }\\n};\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"执行\", _jsx(_components.code, {\n        children: \"stylelint\"\n      }), \"指令得到结果\\n\", _jsx(_components.img, {\n        src: \"/posts-img/stylelint-compat-1.png\",\n        alt: \"PaymentRequest\"\n      }), \"\\n从执行结果可以得到在指定浏览器版本中，\", _jsx(_components.code, {\n        children: \"flexbox-gap\"\n      }), \"和\", _jsx(_components.code, {\n        children: \":not()\"\n      }), \"存在兼容问题\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"也可通过VSCode的\", _jsx(_components.code, {\n        children: \"stylelint\"\n      }), \"插件在编写代码的时候看到错误提示\\n\", _jsx(_components.img, {\n        src: \"/posts-img/stylelint-compat-2.png\",\n        alt: \"PaymentRequest\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"只支持对\", _jsx(_components.code, {\n        children: \"CSS\"\n      }), \"语法的检测，通过配置ignore选择把\", _jsx(_components.code, {\n        children: \"css-nesting\"\n      }), \",CSS嵌套语法校验忽略掉\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"解决兼容问题\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"检测到兼容问题后，需要根据实际情况给出兼容方案，并告知检测工具忽略掉已兼容的功能点。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"JavaScript\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"语法解析\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"语法相关的兼容问题可以通过编译器来转译\"\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"TypeScript\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在\", _jsx(_components.code, {\n        children: \"TypeScript\"\n      }), \"项目中，直接在\", _jsx(_components.code, {\n        children: \"tsconfig.json\"\n      }), \"中声明\", _jsx(_components.code, {\n        children: \"target\"\n      }), \"属性，ts编译器会生成对应版本的js代码。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"比如当设置\", _jsx(_components.code, {\n        children: \"target\"\n      }), \"为\", _jsx(_components.code, {\n        children: \"es2019\"\n      }), \"或更早的版本，使用\", _jsx(_components.code, {\n        children: \"?.\"\n      }), \"，会自动转译如下：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"// ts\\nconst a = {b:1}\\na?.b === 1;\\n\\n// -> js\\n\\\"use strict\\\";\\nconst a = { b: 1 };\\n(a === null || a === void 0 ? void 0 : a.b) === 1;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"使用\", _jsx(_components.code, {\n        children: \"target\"\n      }), \"属性对应的版本之后的版本的功能特性，\", _jsx(_components.code, {\n        children: \"TypeScript\"\n      }), \"编译器也会给出提示\"]\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"Vite应用\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Vite默认使用esbuild来编译，最低兼容es2015\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"使用\", _jsx(_components.code, {\n            children: \"@vitejs/plugin-legacy\"\n          }), \"插件可以兼容更低版本，同时也支持添加polyfills，它是借助\", _jsx(_components.code, {\n            children: \"babel\"\n          }), \"来完成\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"Webpack项目\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"配置\", _jsx(_components.code, {\n        children: \"babel-loader\"\n      }), \"和\", _jsx(_components.code, {\n        children: \"@babel/preset-env\"\n      }), \"来完成转译\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Polyfills\"\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"polyfill.io\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"大部分非语法特性都能在\", _jsx(_components.a, {\n        href: \"https://polyfill.io/\",\n        children: \"polyfill.io\"\n      }), \"上找到补丁，可以根据ECAMScript版本批量添加，也可以单独添加某个特性的Polyfill，直接生成url\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"polyfill.io 会根据请求头部的\", _jsx(_components.code, {\n        children: \"User-Agent\"\n      }), \"来判断当前浏览器需要哪些polyfill\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"也提供了self-hosted版本：\", _jsx(_components.a, {\n        href: \"https://github.com/jakeChampion/polyfill-service-self-hosted/\",\n        children: \"https://github.com/jakeChampion/polyfill-service-self-hosted/\"\n      })]\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"core-js\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"使用npm安装\", _jsx(_components.code, {\n        children: \"core-js\"\n      }), \"后，直接导入需要的包\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"样式\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"检测到样式兼容问题后，解决思路主要有以下几种：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"1 换一种写法实现等价效果\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2 通过寻找PostCSS的插件来解决，部分特性可以通过插件进行转换代码，实现等价的功能\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"3 给出对应的降级兼容方案，在低版本浏览器效果降级\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.postcss.parts/\",\n        children: \"部分插件列表参考\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"autoprefixer\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"用来加给css属性加上不同浏览器的前缀，会从以上\", _jsx(_components.code, {\n        children: \"package.json\"\n      }), \"中声明的\", _jsx(_components.code, {\n        children: \"browserslist\"\n      }), \"为目标\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"一些伪类兼容插件\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.npmjs.com/package/css-has-pseudo\",\n          children: \":has()\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.npmjs.com/package/@csstools/postcss-is-pseudo-class\",\n          children: \":is()\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.npmjs.com/package/postcss-selector-not\",\n          children: \"包含多参数的:not()\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"!: 需要注意的是，使用补丁插件可能存在优先级不一致，性能也可能有一些差异，需要斟酌着使用并花时间做充足的测试。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"项目模板参考\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://github.com/hmilin/react-vite-template\",\n        children: \"https://github.com/hmilin/react-vite-template\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"解决浏览器兼容性问题的思路","date":"2024-02-28 19:00:00","description":"如何在开发时及时发现兼容性问题并解决","category":"tool"}},"frontMatter":{"title":"解决浏览器兼容性问题的思路","date":"2024-02-28 19:00:00","description":"如何在开发时及时发现兼容性问题并解决","category":"tool"},"headings":[{"depth":2,"text":"设定兼容目标"},{"depth":2,"text":"如何在开发时检测兼容性问题"},{"depth":3,"text":"ESLint"},{"depth":3,"text":"StyleLint"},{"depth":2,"text":"解决兼容问题"},{"depth":3,"text":"JavaScript"},{"depth":4,"text":"语法解析"},{"depth":4,"text":"Polyfills"},{"depth":3,"text":"样式"},{"depth":4,"text":"autoprefixer"},{"depth":4,"text":"一些伪类兼容插件"},{"depth":2,"text":"项目模板参考"}]},"__N_SSG":true}