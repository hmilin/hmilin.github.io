{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    h2: \"h2\",\n    img: \"img\",\n    h4: \"h4\",\n    h5: \"h5\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Angular状态管理-Akita\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Akita 是一种状态管理模式，建立在 RxJS 之上，它采用了 Flux 的多个数据存储的思想和 Redux 的不可变更新的思想，以及流数据的概念，创建了 Observable Data Stores 模型。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Akita 鼓励简单。它为您省去了创建样板代码的麻烦，并提供了具有中等学习曲线的强大工具，适合有经验和没有经验的开发人员。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"与 Angular 解耦，可以和其他框架一起使用。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"流程图\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/posts-img/akita.jpg\",\n        alt: \"Akita数据流向\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"基本概念\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"store\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Store 包含 store 状态并作为唯一的真实来源。\"\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"利用 Akita 的 Store 创建一个 store 对象\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"import { Store, StoreConfig } from '@datorama/akita';\\n\\nexport interface SessionState {\\n   token: string;\\n   name: string;\\n}\\n\\nexport function createInitialState(): SessionState {\\n  return {\\n    token: '',\\n    name: ''\\n  };\\n}\\n\\n@StoreConfig({ name: 'session' })\\nexport class SessionStore extends Store<SessionState> {\\n  constructor() {\\n    super(createInitialState());\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"使用 update 方法更新状态\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"import { SessionStore } from './session.store';\\n\\nexport class SessionService {\\n  constructor(private sessionStore: SessionStore) {}\\n\\n  updateUserName(newName: string) {\\n    this.sessionStore.update({ name: newName });\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"setLoading 方法设置 loading 状态\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"import { SessionStore } from './session.store';\\n\\nexport class SessionService {\\n  constructor(private sessionStore: SessionStore,\\n              private http: HttpClient) {}\\n\\n  async updateUserName(newName: string) {\\n    this.sessionStore.setLoading(true);\\n    await this.http(...).toPromise();\\n    this.sessionStore.update({ name: newName});\\n    this.sessionStore.setLoading(false);\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"setError 方法抛出错误\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"import { SessionStore } from './session.store';\\n\\nexport class SessionService {\\n  constructor(private sessionStore: SessionStore,\\n              private http: HttpClient) {}\\n\\n  async updateUserName(newName: string) {\\n    try {\\n      await this.http(...).toPromise();\\n    } catch(error) {\\n      this.sessionStore.setError(error);\\n    }\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"使用 destroy 方法销毁 store\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"sessionStore.destroy();\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Query\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Query 提供查询store的功能，通过 constructor 来接收自己的 store 和其他 query\"\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"创建Query\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"import { Query } from '@datorama/akita';\\nimport { SessionState, SessionStore } from './session.store';\\n\\nexport class SessionQuery extends Query<SessionState> {  \\n  constructor(protected store: SessionStore) {\\n    super(store);\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"使用select方法获取observable类型的state值\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\nimport { Query } from '@datorama/akita';\\nimport { SessionState } from './session.store';\\n\\nexport class SessionQuery extends Query<SessionState> {\\n  allState$ = this.select();\\n  isLoggedIn$ = this.select(state => !!state.token);\\n  selectName$ = this.select('name');\\n\\n  // Returns { name, age }\\n  multiProps$ = this.select(['name', 'age']);\\n\\n  // Returns [name, age]\\n  multiPropsCallback$ = this.select(\\n    [state => state.name, state => state.age]\\n  )\\n  \\n  constructor(protected store: SessionStore) {\\n    super(store);\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"使用getValue方法获取当前state值\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\nimport { Query } from '@datorama/akita';\\nimport { SessionState } from './session.store';\\n\\nexport class SessionQuery extends Query<SessionState> {\\n\\n  constructor(protected store: SessionStore) {\\n    super(store);\\n  }\\n\\n  get isLoggedIn() {\\n    return !!this.getValue().token;\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"selectLoading 和 selectError 可以获取loading和error，返回Observable类型\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\n@Component({})\\nexport class LoginComponent {\\n  isLoading$ = this.sessionQuery.selectLoading();\\n\\t error$ = this.sessionQuery.selectError();\\n\\n  constructor(private sessionQuery: SessionQuery) {}\\n}\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"Angular状态管理-Akita","description":"Akita 是一种状态管理模式，建立在 RxJS 之上，它采用了 Flux 的多个数据存储的思想和 Redux 的不可变更新的思想，以及流数据的概念，创建了 Observable Data Stores 模型。","date":"2021-08-30 21:17:00","cover":"/posts-img/akita.jpg"}},"frontMatter":{"title":"Angular状态管理-Akita","description":"Akita 是一种状态管理模式，建立在 RxJS 之上，它采用了 Flux 的多个数据存储的思想和 Redux 的不可变更新的思想，以及流数据的概念，创建了 Observable Data Stores 模型。","date":"2021-08-30 21:17:00","cover":"/posts-img/akita.jpg"}},"__N_SSG":true}