{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    blockquote: \"blockquote\",\n    p: \"p\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"TypeScript 装饰器使用\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"装饰器模式，又名装饰者模式。它的定义是“在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求”。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"根据装饰对象分类常见的装饰器有三种，类装饰器、属性装饰器和函数装饰器。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"使用装饰器工厂生成装饰器\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"定义一个装饰器工厂格式大概如下：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"其实就是定义一个函数，该函数返回一个另一个函数，对装饰对象进行处理之后将结果返回。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"function name () {\\n    return function(target: IConfirmableDirective, propertyKey: string, descriptor: PropertyDescriptor) {\\n            // TODO 对装饰对象的处理，并返回处理结果\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"第一层函数可以传入装饰器参数\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"function name(value: string) {\\n    return function() {}\\n}\\n// 即是这么使用\\n@name('111') ...\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"第二层函数的参数即是装饰对象的源数据\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"target:  装饰类的构造函数\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"propertyKey: 属性的key值\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"descriptor: 装饰对象的PropertyDescriptor\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"装饰器使用示例\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"删除操作二次确认是日常开发中很常见的场景，正常的实现思路是点击删除按钮时执行一个函数，这个函数的内容包括打开一个确认框，定义好回调函数，等二次确定后执行回调。大致如下：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"delete() {\\n   this.noticeService.dialog({\\n      title,\\n      theme: 'error',\\n      body: description,\\n      callback: (ret: boolean) => {\\n        if (!ret) {\\n          return;\\n        }\\n        // 执行删除函数\\n      },\\n    });\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果使用装饰器改写，只需要在函数前面加个装饰器，不需要修改函数本身，并且看起来更优雅简洁。调用方式如下：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \" @deleteConfirm('删除应用', '确定删除应用？')\\n delete() {\\n     // 删除操作 \\n }\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"装饰器实现代码如下：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"interface IConfirmableDirective {\\n  injector: Injector;\\n  ngOnInit?: Function;\\n}\\nexport default function deleteConfirm(title: string, description: string) {\\n  return function (\\n    target: IConfirmableDirective,\\n    key: string,\\n    descriptor: PropertyDescriptor\\n  ) {\\n    const originalMethod = descriptor.value;\\n    const originNgOninit = target.ngOnInit;\\n    let noticeService: NoticeService;\\n    target.ngOnInit = function (this: IConfirmableDirective) {\\n      originNgOninit && originNgOninit.apply(this);\\n      noticeService = this.injector.get(NoticeService);\\n    };\\n    descriptor.value = async function (...args: any[]) {\\n      let confirm = new Promise<boolean>((resolve) => {\\n        noticeService.dialog({\\n          title,\\n          theme: 'error',\\n          body: description,\\n          callback: (ret: boolean) => {\\n            if (!ret) {\\n              resolve(false);\\n              return;\\n            }\\n            resolve(true);\\n          },\\n        });\\n      });\\n      let res = await confirm;\\n      if (res) {\\n        const result = originalMethod.apply(this, args);\\n        return result;\\n      }\\n    };\\n    return descriptor;\\n  };\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Ng-Zorro中的装饰器\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"上面我们简单实现了一个装饰器工厂，但是有很多代码是每次定义装饰器的时候都要重复写的。在Ng-Zorro中，就被提取为一个公共函数，避免了很多重复的代码，并且避免了装饰器命名重复。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"function propDecoratorFactory<T, D>(\\n  name: string,\\n  fallback: (v: T) => D\\n): (target: NzSafeAny, propName: string) => void {\\n  function propDecorator(\\n    target: NzSafeAny,\\n    propName: string,\\n    originalDescriptor?: TypedPropertyDescriptor<NzSafeAny>\\n  ): NzSafeAny {\\n    const privatePropName = `$$__zorroPropDecorator__${propName}`;\\n    if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {\\n      warn(`The prop \\\"${privatePropName}\\\" is already exist, it will be overrided by ${name} decorator.`);\\n    }\\n    Object.defineProperty(target, privatePropName, {\\n      configurable: true,\\n      writable: true\\n    });\\n    return {\\n      get(): string {\\n        return originalDescriptor && originalDescriptor.get\\n          ? originalDescriptor.get.bind(this)()\\n          : this[privatePropName];\\n      },\\n      set(value: T): void {\\n        if (originalDescriptor && originalDescriptor.set) {\\n          originalDescriptor.set.bind(this)(fallback(value));\\n        }\\n        this[privatePropName] = fallback(value);\\n      }\\n    };\\n  }\\n  return propDecorator;\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这样，声明一个装饰器会变得更简洁：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"export function InputBoolean(): NzSafeAny {\\n  return propDecoratorFactory('InputBoolean', toBoolean);\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"常见的业务场景\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"实现React高阶组件。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"对属性进行格式转换，通常格式化数据我们会使用定义函数的方式对数据修改然后返回，也可以尝试使用装饰器，让代码更优雅一些。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"对函数执行之前进行拦截，例如上面的删除确认拦截。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"对类功能的扩展，在不改变源代码的情况下对功能扩展，使代码更具维护性。\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"TypeScript 装饰器使用","date":"2021-09-24 19:00:00","description":"TypeScript 装饰器使用","category":"native"}},"frontMatter":{"title":"TypeScript 装饰器使用","date":"2021-09-24 19:00:00","description":"TypeScript 装饰器使用","category":"native"},"headings":[{"depth":2,"text":"使用装饰器工厂生成装饰器"},{"depth":2,"text":"装饰器使用示例"},{"depth":2,"text":"Ng-Zorro中的装饰器"},{"depth":2,"text":"常见的业务场景"}]},"__N_SSG":true}