{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"工作过程中经常遇到已经开发好的功能有一些小变动，一个小功能多次提交看着总是不太舒服，需要使用cherry-pick的时也不方便。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"往上一个提交追加内容\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"使用 git commit --amend  即可\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"修改某一个历史提交\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"找到该提交的上一个commitId，执行\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"git rebase <commitId> --interactive\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在vi中将pick改为edit，执行 git add ,然后 git commit --amend，最后执行 git rebase --continue\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"将多个commit合并为一个\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Step 1.  git rebase -i   commit-id    会合并此次提交之后所有的提交为一个提交， 注意此次提交不会包含在内。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Step 2.  在 vim 编辑器中 会列出所有要合并的提交， 并修改内容,  保存并推出vim。\\n           pick  commit-id-1  commit-msg-1   =>  pick  commit-id-1  commit-msg-1\\n           pick commit-id-2  commit-msg-2   =>  s commit-id-2  commit-msg-2\\n           pick commit-id-3  commit-msg-3  =>   s commit-id-3  commit-msg-3\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"step 3.  如果有冲突发生，解决冲突后并git add 然后运行  git rebase --continue,  在弹出的vim编辑器重重新编辑提交message. \\n            然后保存并退出。 如果要终止这次合并 git rebase --abort ,  git rebase --edit-todo 重新查看和编辑。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Step 4. 如果远程仓库有当前分支，则可能会让我们进行git pull 操作， 此时执行 git push origin :branch-name  删除远程分支， \\n           git branch --unset-upstream  将本地分支和远程分支进行解除关联。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Step 5. 最后运行 git push --set-upstream origin branch-name,  将本地合并的提交推送到远程仓库。 \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"pick：简写p，表示启用该commitId\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"reword：简写r，使用该comitId，但是修改提交信息，修改后可以继续编辑后面的提交信息\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"edit：简写e，使用该commitId，停止合并该commitId\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"squash：简写s，使用该commitId，并将该commitId并入前一个commitId\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"drop：简写d，移除该commitId\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"Git commit 修改","date":"2021-03-13 20:53:00","description":"Git Rebase的使用。","category":"tool"}},"frontMatter":{"title":"Git commit 修改","date":"2021-03-13 20:53:00","description":"Git Rebase的使用。","category":"tool"},"headings":[{"depth":3,"text":"往上一个提交追加内容"},{"depth":3,"text":"修改某一个历史提交"},{"depth":3,"text":"将多个commit合并为一个"}]},"__N_SSG":true}