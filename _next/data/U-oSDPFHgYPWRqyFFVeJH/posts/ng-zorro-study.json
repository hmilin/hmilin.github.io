{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    ol: \"ol\",\n    li: \"li\",\n    ul: \"ul\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Ng-Zorro代码鉴赏\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"目录\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \"| 文件/文件名称 | 说明 | \\n| components | 组件文件夹，包含框架组件源码 |\\n| docs | 非组件文章文档，如国际化、全局配置等 |\\n| integration | 构建操作工具，搭配 travis 使用 |\\n| schematics | 自定义脚手架，ng g add ng-zorro-antd |\\n| scripts | 发布/调试脚本 |\\n| CODE_OF_CONDUCT.md | 贡献指南 |\\n| CHANGELOG.md | 发布日志 |\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"其中components/core 放了一些公共代码\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"关于和ant-design保持样式统一，他们使用了\", _jsx(_components.a, {\n        href: \"https://github.com/ng-zorro-bot\",\n        children: \"机器人\"\n      }), \"从ant-design同步样式代码。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"ONPUSH变更检测模式的使用\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"angular中有两种检测模式，一种是CheckAlways，一种是CheckOnce，通过component装饰器的changeDetection字段来定义\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"@Component({\\n  changeDetection: ChangeDetectionStrategy.OnPush\\n})\\nexport declare enum ChangeDetectionStrategy {\\n    /**\\n     * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\\n     * until reactivated by setting the strategy to `Default` (`CheckAlways`).\\n     * Change detection can still be explicitly invoked.\\n     * This strategy applies to all child directives and cannot be overridden.\\n     */\\n    OnPush = 0,\\n    /**\\n     * Use the default `CheckAlways` strategy, in which change detection is automatic until\\n     * explicitly deactivated.\\n     */\\n    Default = 1\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"OnPush模式的使用:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"由\", _jsx(_components.a, {\n        href: \"https://angular.cn/api/core/ChangeDetectorRef\",\n        children: \"ChangeDetectorRef\"\n      }), \"提供变更检测功能\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"abstract class ChangeDetectorRef {\\n  abstract markForCheck(): void // 当视图使用 OnPush（checkOnce）变更检测策略时，把该视图显式标记为已更改，以便它再次进行检查。\\n  abstract detach(): void // 从变更检测树中分离开视图。 \\n  abstract detectChanges(): void // 检查该视图及其子视图。\\n  abstract checkNoChanges(): void // 检查变更检测器及其子检测器，如果检测到任何更改，则抛出异常。\\n  abstract reattach(): void // 把以前分离开的视图重新附加到变更检测树上。 视图会被默认附加到这棵树上。\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"使用示例：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"zorro中这段代码出现过很多次，作用是当全局配置中对应当前组件的配置修改时，将视图标记为需检测。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"this.nzConfigService\\n    .getConfigChangeEventForComponent(NZ_CONFIG_COMPONENT_NAME)\\n    .pipe(takeUntil(this.destroy$))\\n    .subscribe(() => {\\n    this.cdr.markForCheck();\\n});\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"表单控件中，当writeVaule执行时（即将变化的数据写入视图时），标记为需检测。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"writeValue(value: number): void {\\n    this.value = value;\\n    this.setValue(value);\\n    this.updateDisplayValue(value);\\n    this.cdr.markForCheck();\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"使用\", _jsx(_components.a, {\n        href: \"https://angular.cn/api/core/NgZone\",\n        children: \"NgZone\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Zone 是跨异步任务而持久存在的执行上下文。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ngZone基于zone.js，是Angular变更检测的基础，Angular通过zone监听到了异步任务的执行过程，便于在异步任务执行时触发变更检测。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"使用\", _jsx(_components.code, {\n        children: \"ngZone.runOutsideAngular\"\n      }), \"让代码执行不触发新的变更检测，在调用\", _jsx(_components.code, {\n        children: \"run\"\n      }), \"将这些任务重新进入Angular zone\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"this.ngZone.runOutsideAngular(() => {\\n      fromEvent<MouseEvent>(this.elementRef.nativeElement, 'click')\\n        .pipe(takeUntil(this.destroy$))\\n        .subscribe(event => {\\n          /** prevent label click triggered twice. **/\\n          event.stopPropagation();\\n          event.preventDefault();\\n          if (this.nzDisabled || this.isChecked) {\\n            return;\\n          }\\n          this.ngZone.run(() => {\\n            if (this.nzRadioService) {\\n              this.nzRadioService.select(this.nzValue);\\n            }\\n            if (this.isNgModel) {\\n              this.isChecked = true;\\n              this.onChange(true);\\n            }\\n            this.cdr.markForCheck();\\n          });\\n        });\\n    });\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"对templateRef传参的处理\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Zorro的组件中很多支持\", _jsx(_components.code, {\n        children: \"string | TemplateRef<void>\"\n      }), \"这种类型的传参，用于将字符串或模板植入组件视图。angular有一个\", _jsx(_components.a, {\n        href: \"https://angular.cn/api/common/NgTemplateOutlet\",\n        children: \"NgTemplateOutlet\"\n      }), \"指令，用于将templateRef插入视图，为了同时处理TemplateRef和string类型，zorro中封装了一个类似的指令\", _jsx(_components.code, {\n        children: \"nzStringTemplateOutlet\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"核心代码为\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"constructor(private viewContainer: ViewContainerRef, private templateRef: TemplateRef<NzSafeAny>) {}\\n\\nprivate recreateView(): void {\\n    this.viewContainer.clear();\\n    const isTemplateRef = this.nzStringTemplateOutlet instanceof TemplateRef;\\n    const templateRef = (isTemplateRef ? this.nzStringTemplateOutlet : this.templateRef) as NzSafeAny;\\n    this.embeddedViewRef = this.viewContainer.createEmbeddedView(\\n    templateRef,\\n    isTemplateRef ? this.nzStringTemplateOutletContext : this.context\\n    );\\n}\\n  \\nngOnChanges(changes: SimpleChanges): void {\\n    // ...\\n     if (recreateView) {\\n      /** recreate view when context shape or outlet change **/\\n      this.recreateView();\\n    } else {\\n    // ...\\n\\t}\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在很多个组件文件里都能看到他的使用，大概如下:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"<ng-container *nzStringTemplateOutlet=\\\"nzMessage\\\">{{ nzMessage }}</ng-container>\\n@Input() nzMessage: string | TemplateRef<void> | null = null;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"指令是Angular中用于封装公共行为的强有力工具，它拥有了对模板的控制权，和组件一样拥有生命周期，但是使用起来更灵活。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"对装饰器的使用\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"属性装饰器\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"zorro中基本每一个组件都会看到@InputNumber、@InputBoolean这样的装饰器使用，用于对输入参数进行强制类型转换，避免因类型错误影响后面程序运行。\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"在typescript中声明一个工厂装饰器的思路大致如下：\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-typescript\",\n            children: \"function name () {\\n    return function(target: IConfirmableDirective, propertyKey: string, descriptor: PropertyDescriptor) {\\n            // TODO 对装饰对象的处理，并返回新的descriptor\\n    }\\n}\\n\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"zorro中定义了一个生产属性装饰器的函数，传入装饰器名称和对属性的处理函数，即可生成一个装饰器。\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-typescript\",\n            children: \"function propDecoratorFactory<T, D>(\\n  name: string,\\n  fallback: (v: T) => D\\n): (target: NzSafeAny, propName: string) => void {\\n  function propDecorator(\\n    target: NzSafeAny,\\n    propName: string,\\n    originalDescriptor?: TypedPropertyDescriptor<NzSafeAny>\\n  ): NzSafeAny {\\n    const privatePropName = `$$__zorroPropDecorator__${propName}`;\\n\\n    if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {\\n      warn(`The prop \\\"${privatePropName}\\\" is already exist, it will be overrided by ${name} decorator.`);\\n    }\\n\\n    Object.defineProperty(target, privatePropName, {\\n      configurable: true,\\n      writable: true\\n    });\\n\\n    return {\\n      get(): string {\\n        return originalDescriptor && originalDescriptor.get\\n          ? originalDescriptor.get.bind(this)()\\n          : this[privatePropName];\\n      },\\n      set(value: T): void {\\n        if (originalDescriptor && originalDescriptor.set) {\\n          originalDescriptor.set.bind(this)(fallback(value));\\n        }\\n        this[privatePropName] = fallback(value);\\n      }\\n    };\\n  }\\n\\n  return propDecorator;\\n}\\n\\nexport function InputBoolean(): NzSafeAny {\\n  return propDecoratorFactory('InputBoolean', toBoolean);\\n}\\n\\n\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"从全局配置中获取默认数值的装饰器\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"zorro提供了一个\", _jsx(_components.code, {\n            children: \"NzConfigService\"\n          }), \"类，可以通过依赖注入的方式或者调用api的方式来设置组件的默认配置\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-typescript\",\n            children: \"export function WithConfig<T>() {\\n  return function ConfigDecorator(\\n    target: NzSafeAny,\\n    propName: NzSafeAny,\\n    originalDescriptor?: TypedPropertyDescriptor<T>\\n  ): NzSafeAny {\\n    const privatePropName = `$$__zorroConfigDecorator__${propName}`;\\n\\n    Object.defineProperty(target, privatePropName, {\\n      configurable: true,\\n      writable: true,\\n      enumerable: false\\n    });\\n\\n    return {\\n      get(): T | undefined {\\n        const originalValue = originalDescriptor?.get ? originalDescriptor.get.bind(this)() : this[privatePropName];\\n        const assignedByUser = (this.propertyAssignCounter?.[propName] || 0) > 1;\\n        const configValue = this.nzConfigService.getConfigForComponent(this._nzModuleName)?.[propName];\\n        if (assignedByUser && isDefined(originalValue)) {\\n          return originalValue;\\n        } else {\\n          return isDefined(configValue) ? configValue : originalValue;\\n        }\\n      },\\n      set(value?: T): void {\\n        // If the value is assigned, we consider the newly assigned value as 'assigned by user'.\\n        this.propertyAssignCounter = this.propertyAssignCounter || {};\\n        this.propertyAssignCounter[propName] = (this.propertyAssignCounter[propName] || 0) + 1;\\n\\n        if (originalDescriptor?.set) {\\n          originalDescriptor.set.bind(this)(value!);\\n        } else {\\n          this[privatePropName] = value;\\n        }\\n      },\\n      configurable: true,\\n      enumerable: true\\n    };\\n  };\\n}\\n\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"在组件中使用如下:\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-typescript\",\n            children: \"@Input() @WithConfig() nzSize: NzSizeLDSType | number = 'default';\\n\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"如何保证优先级?\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"组件调用>用户配置>默认配置\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-typescript\",\n            children: \"const assignedByUser = (this.propertyAssignCounter?.[propName] || 0) > 1;\\n\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"每次调用set的时候会+1，大于1说明用户自己设置了，使用用户设置的值，否则先读配置里，没有的话再读组件里的默认值。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"使用\", _jsx(_components.a, {\n        href: \"https://v12.material.angular.io/cdk/overlay/overview\",\n        children: \"angular/cdk/overlay\"\n      }), \"对浮层进行统一管理\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"为什么需要对浮层进行统一管理？\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"规避父元素样式的影响（比如transition属性的影响）\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"在创建和销毁弹出层时，避免影响应用主体\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"方便 z-index 的设置与管理\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"@angular/cdk的overlay模块提供了一套管理浮层的功能\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"使用大致如下：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"const containerPortal = new ComponentPortal<BaseModalContainerComponent>(\\n      ContainerComponent,\\n      config.nzViewContainerRef,\\n      injector\\n    );\\nconst containerRef = overlayRef.attach<BaseModalContainerComponent>(containerPortal);\\n\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"Ng-Zorro代码鉴赏","date":"2021-12-10 13:55:00","description":"Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。","category":"framework"}},"frontMatter":{"title":"Ng-Zorro代码鉴赏","date":"2021-12-10 13:55:00","description":"Ng-Zorro是ant-design组件库的angular实现，前段时间我们在项目中将组件库换成Zorro，因此看了一下代码实现，总结一些好的写法。","category":"framework"},"headings":[{"depth":2,"text":"目录"},{"depth":2,"text":"ONPUSH变更检测模式的使用"},{"depth":2,"text":"使用"},{"depth":2,"text":"对templateRef传参的处理"},{"depth":2,"text":"对装饰器的使用"},{"depth":2,"text":"使用对浮层进行统一管理"}]},"__N_SSG":true}