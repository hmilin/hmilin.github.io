{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    h2: \"h2\",\n    h3: \"h3\",\n    ol: \"ol\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\"\n  }, _provideComponents(), props.components), {SimpleLinearPopover, LinearPopover} = _components;\n  if (!LinearPopover) _missingMdxReference(\"LinearPopover\", true);\n  if (!SimpleLinearPopover) _missingMdxReference(\"SimpleLinearPopover\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"实现渐变背景的气泡框\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"传统的气泡框一般使用一个圆角div+三角形来模拟，在背景色为普通颜色时，分别设置背景色即可达到理想的效果。然而将背景色改为渐变色时，分别给两部分元素设置背景色，无法设置出连续的颜色，所以原先的实现方式不适用。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"初始方案\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"实现逻辑\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"画一个渐变色背景的矩形\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"使用和背景色一致的颜色遮罩盖住无需展示的部分，模拟三角形和圆角\", \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"远离箭头的矩形正常设置border-radius\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"靠近箭头的矩形圆角使用两个遮罩来模拟，使用clip-path的path函数实现\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"使用clip-path的polygon（多边形）函数截取三角形的反转部分，遮住非三角形的部分。\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"示例代码：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import classNames from \\\"classnames\\\";\\nimport type { PropsWithChildren } from \\\"react\\\";\\n\\nimport styles from \\\"./styles.module.css\\\";\\n\\ntype ArrowDirection = \\\"left\\\" | \\\"right\\\";\\n\\ninterface SimpleLinearPopoverProps {\\n  arrowDirection?: ArrowDirection;\\n  parrentBackground?: string;\\n}\\n\\nconst SimpleLinearPopover: React.FC<PropsWithChildren<SimpleLinearPopoverProps>> = ({\\n  arrowDirection = \\\"left\\\",\\n  parrentBackground = \\\"#fff\\\",\\n  children,\\n}) => {\\n  return (\\n    <div\\n      className={classNames(\\n        styles[\\\"simple-popover-container\\\"],\\n        styles[`simple-popover-container-direction-${arrowDirection}`]\\n      )}\\n      style={{\\n        \\\"--parent-background-color\\\": parrentBackground,\\n      }}\\n    >\\n      <div className={styles[\\\"simple-popover-content\\\"]}>{children}</div>\\n      <div className={styles[\\\"simple-popover-arrow\\\"]}></div>\\n    </div>\\n  );\\n};\\n\\nexport default SimpleLinearPopover;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-css\",\n        children: \".simple-popover-container {\\n  position: relative;\\n  width: fit-content;\\n  max-width: 100%;\\n  padding: 12px 24px 12px 16px;\\n  word-break: break-all;\\n  color: #fff;\\n  background: linear-gradient(137deg, #efe2b7 0%, #a4d1b1 90%);\\n  border-radius: 12px;\\n  white-space: pre-wrap;\\n}\\n\\n.simple-popover-container.simple-popover-container-direction-left {\\n  transform: rotateY(180deg);\\n}\\n.simple-popover-container.simple-popover-container-direction-right {\\n  transform: unset;\\n}\\n\\n.simple-popover-content {\\n  overflow: auto;\\n}\\n\\n.simple-popover-container.simple-popover-container-direction-left\\n  .simple-popover-content {\\n  transform: rotateY(180deg);\\n}\\n\\n/* 上圆角 */\\n.simple-popover-container:before {\\n  position: absolute;\\n  top: -2px;\\n  right: 6px;\\n  content: \\\"\\\";\\n  width: 14px;\\n  height: 14px;\\n  background: var(--parent-background-color);\\n  clip-path: path(\\\"M 0 0 L 0 2 A 12 12 0 0 1 12 14 L 14 14 L 14 0 0 0 Z\\\");\\n}\\n\\n/* 下圆角 */\\n.simple-popover-container:after {\\n  position: absolute;\\n  bottom: -2px;\\n  right: 6px;\\n  content: \\\"\\\";\\n  width: 14px;\\n  height: 14px;\\n  background: var(--parent-background-color);\\n  clip-path: path(\\\"M 14 0 L 12 0 A 12 12 0 0 1 0 12 L 0 14 L 14 14 14 0 Z\\\");\\n}\\n\\n/* 箭头 */\\n.simple-popover-arrow:after {\\n  position: absolute;\\n  top: 0;\\n  right: -2px;\\n  content: \\\"\\\";\\n  width: 10px;\\n  height: 100%;\\n  background: var(--parent-background-color);\\n  clip-path: polygon(\\n    100% 0,\\n    0 0,\\n    0 12px,\\n    8px 21px,\\n    0 30px,\\n    0 100%,\\n    100% 100%,\\n    100% 21px\\n  );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"效果如下：\"\n    }), \"\\n\", _jsx(\"div\", {\n      style: {\n        marginBottom: 16\n      },\n      children: _jsx(SimpleLinearPopover, {\n        parrentBackground: \"#FFF9ED\",\n        children: \"hello!\"\n      })\n    }), \"\\n\", _jsx(SimpleLinearPopover, {\n      parrentBackground: \"#FFF9ED\",\n      arrowDirection: \"right\",\n      children: \"hello!\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h3, {\n      children: \"局限\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"只能适用于背景色为纯色的场景，对背景为图片或带透明叠加效果的场景不适用\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"改良方案\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"仅用一个div+clip-path，将气泡框描绘出来，由于path函数中只能声明固定坐标点而不能用百分比，而气泡框的宽高需要根据内容自适应，因此需要监听div的大小变化，计算出path的路径。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"示例代码：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import classNames from \\\"classnames\\\";\\nimport { PropsWithChildren, useLayoutEffect, useRef, useState } from \\\"react\\\";\\nimport styles from \\\"./styles.module.css\\\";\\n\\ntype ArrowDirection = \\\"left\\\" | \\\"right\\\";\\n\\ninterface LinearPopoverProps {\\n  arrowDirection?: ArrowDirection;\\n}\\n\\nconst LinearPopover: React.FC<PropsWithChildren<LinearPopoverProps>> = ({\\n  arrowDirection = \\\"left\\\",\\n  children,\\n}) => {\\n  const containerRef = useRef<HTMLDivElement>(null);\\n\\n  useLayoutEffect(() => {\\n    if (containerRef.current) {\\n      const resizeObserver = new ResizeObserver((entries) => {\\n        for (const entry of entries) {\\n          if (entry.contentRect) {\\n            const { width, height } = entry.target.getBoundingClientRect();\\n            const path = genPopoverPath(width, height);\\n            containerRef.current!.style[\\\"clip-path\\\"] = `path('${path}')`;\\n          }\\n        }\\n      });\\n      resizeObserver.observe(containerRef.current);\\n      return () => {\\n        resizeObserver.disconnect();\\n      };\\n    }\\n  }, []);\\n\\n  return (\\n    <div\\n      ref={containerRef}\\n      className={classNames(\\n        styles[\\\"popover-container\\\"],\\n        styles[`popover-container-direction-${arrowDirection}`]\\n      )}\\n    >\\n      <div className=\\\"popover-container-content\\\">{children}</div>\\n    </div>\\n  );\\n};\\n\\nfunction genPopoverPath(width: number, height: number) {\\n  const borderRadius = 12;\\n  const arrowWidth = 10;\\n  const path = `M 0 ${borderRadius}\\n   A ${borderRadius} ${borderRadius} 0 0 1 ${borderRadius} 0 \\n   L ${width - borderRadius - arrowWidth} 0 \\n   A ${borderRadius} ${borderRadius} 0 0 1 ${\\n    width - arrowWidth\\n  } ${borderRadius} \\n   L  ${width - arrowWidth} ${borderRadius} \\n   L ${width} 21 \\n   L ${width - arrowWidth} 30 \\n   L ${width - arrowWidth} ${height - borderRadius} \\n   A ${borderRadius} ${borderRadius} 0 0 1 ${\\n    width - borderRadius - arrowWidth\\n  } ${height} \\n   L ${borderRadius} ${height}  \\n   A ${borderRadius} ${borderRadius} 0 0 1 0 ${height - borderRadius}\\n   L 0 ${borderRadius} Z`;\\n\\n  return path.replaceAll(\\\"\\\\n\\\", \\\"\\\");\\n}\\n\\nexport default LinearPopover;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-css\",\n        children: \"\\n.popover-container {\\n  position: relative;\\n  width: fit-content;\\n  max-width: 100%;\\n  padding: 12px 24px 12px 16px;\\n  word-break: break-all;\\n  color: #fff;\\n  background: linear-gradient(137deg, #efe2b7 0%, #a4d1b1 90%);\\n  white-space: pre-wrap;\\n}\\n\\n.popover-container.popover-container-direction-right {\\n  transform: rotateY(180deg);\\n}\\n.popover-container.popover-container-direction-right\\n  .popover-container-content {\\n  transform: rotateY(180deg);\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"效果如下：\"\n    }), \"\\n\", _jsx(\"div\", {\n      style: {\n        marginBottom: 16\n      },\n      children: _jsx(LinearPopover, {\n        children: \"hello!\"\n      })\n    }), \"\\n\", _jsx(LinearPopover, {\n      arrowDirection: \"right\",\n      children: \"hello!\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h2, {\n      children: \"参考资料\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/d#%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF\",\n        children: \"path椭圆曲线\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"实现渐变背景的气泡框","description":"使用css实现渐变色背景的气泡框","public":true,"date":"2024-07-19 12:01:00","category":"native"}},"frontMatter":{"title":"实现渐变背景的气泡框","description":"使用css实现渐变色背景的气泡框","public":true,"date":"2024-07-19 12:01:00","category":"native"},"headings":[{"depth":2,"text":"初始方案"},{"depth":3,"text":"实现逻辑"},{"depth":3,"text":"局限"},{"depth":2,"text":"改良方案"},{"depth":2,"text":"参考资料"}]},"__N_SSG":true}