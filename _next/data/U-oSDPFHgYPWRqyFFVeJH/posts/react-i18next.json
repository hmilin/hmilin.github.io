{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    code: \"code\",\n    h2: \"h2\",\n    ol: \"ol\",\n    li: \"li\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"使用react-i18next进行国际化配置\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"本文记录了如何\", _jsx(_components.code, {\n        children: \"react-i18next\"\n      }), \"的基础配置、跟typescript的结合使用、在组件内外的使用和如何通过自定义脚本来提高翻译文本输出。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"基础使用\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"安装 \", _jsx(_components.code, {\n          children: \"i18next\"\n        }), \" 和 \", _jsx(_components.code, {\n          children: \"react-i18next\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"在\", _jsx(_components.code, {\n          children: \"src\"\n        }), \"目录下创建\", _jsx(_components.code, {\n          children: \"i18n.ts\"\n        }), \"文件，并创建\", _jsx(_components.code, {\n          children: \"locales\"\n        }), \"目录来存放不同语言对应的翻译\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import { setValidateLanguage } from '@formily/core';\\nimport i18n from 'i18next';\\nimport { initReactI18next } from 'react-i18next';\\nimport en from './locales/en/translation.json';\\nimport zh from './locales/zh/translation.json';\\n\\nconst defaultLg = localStorage.getItem('locale') || 'zh-CN';\\ni18n.use(initReactI18next).init({\\n  fallbackLng: defaultLg,\\n  debug: true,\\n  interpolation: {\\n    escapeValue: false, // not needed for react as it escapes by default\\n  },\\n  resources: {\\n    'en-US': {\\n      translation: en,\\n    },\\n    'zh-CN': {\\n      translation: zh,\\n    },\\n  },\\n});\\n\\nexport default i18n;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"并在\", _jsx(_components.code, {\n        children: \"App.tsx\"\n      }), \"中导入\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"定义语言切换组件，通过调用\", _jsx(_components.code, {\n          children: \"i18n\"\n        }), \"实例下的\", _jsx(_components.code, {\n          children: \"changeLanguage\"\n        }), \"方法来切换语言，并使用\", _jsx(_components.code, {\n          children: \"localStorage\"\n        }), \"来持久化数据\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import { TranslationOutlined } from '@ant-design/icons';\\nimport { Dropdown } from 'antd';\\nimport { useTranslation } from 'react-i18next';\\n\\nconst items = [\\n  {\\n    key: 'en-US',\\n    label: 'English',\\n  },\\n  {\\n    key: 'zh-CN',\\n    label: '中文',\\n  },\\n];\\n\\ninterface LanguageChangerProps {}\\n\\nconst LanguageChanger: React.FC<LanguageChangerProps> = () => {\\n  const { i18n } = useTranslation();\\n\\n  const handleChange = (key: string) => {\\n    i18n.changeLanguage(key);\\n    localStorage.setItem('locale', key);\\n  };\\n\\n  return (\\n    <Dropdown\\n      menu={{\\n        items,\\n        selectedKeys: [i18n.language],\\n        onClick: ({ key }) => handleChange(key),\\n      }}\\n    >\\n      <div className=\\\"header-item\\\">\\n        <TranslationOutlined />\\n      </div>\\n    </Dropdown>\\n  );\\n};\\n\\nexport default LanguageChanger;\\n\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"通过translation文件中对应的key来使用，考虑到随着业务的新增翻译配置会越来越多，提前将配置进行分组\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-json\",\n        children: \"{\\n  // 全局公共配置\\n  \\\"global\\\": {\\n     // 页面导航\\n    \\\"pages\\\": {},\\n    // 基础公共配置\\n    \\\"common\\\": {\\n      \\\"confirmTitle\\\": \\\"确认\\\"\\n    },\\n    // 模板\\n    \\\"templates\\\": {\\n      \\\"remove_confirm\\\": \\\"确定删除{{target}} <strong>{{name}}</strong>？\\\"\\n    },\\n    // 提示语\\n    \\\"messages\\\": {\\n      \\\"remove_successful\\\": \\\"删除成功！\\\",\\n      \\\"save_successful\\\": \\\"保存成功！\\\"\\n    }\\n  },\\n  //根据业务对象进行分类\\n  \\\"users\\\": {},\\n  \\\"projects\\\": {},\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Typescript配置实现提示\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"经过以上配置后，我们就可以通过上面配置的key来使用国际化文本，比如在组件中调用\", _jsx(_components.code, {\n        children: \"useTranslation\"\n      }), \"API返回的t方法来获取文本\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \" const { t } = useTranslation();\\n return t('global.common.hello')\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"react-i18next\"\n      }), \"支持通过ts的类型配置来实现提示\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"在src/@types下目录下建立resources.ts，导入主语言的配置\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import translation from '../locales/zh/translation.json';\\n\\nconst resources = {\\n  translation,\\n} as const;\\n\\nexport default resources;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"在src/@types下目录下建立i18next.d.ts，并添加以下配置：\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"import resources from './resources';\\n\\ndeclare module 'i18next' {\\n  interface CustomTypeOptions {\\n    resources: typeof resources;\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"再次调用t方法时，就能看见类型的提示了。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"在多种场景下的使用方式\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"在组件中使用\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"const { t } = useTranslation();\\nt('global.common.hello')\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"在组件外使用\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在组件作用域外的文本，可以调用Translation组件来使用，为了方便调用可以封装以下组件\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"import type { KeyPrefix } from 'i18next';\\nimport { Translation as TranslationBase } from 'react-i18next';\\n\\ntype Keys = KeyPrefix<'translation'>;\\n\\ninterface TranslationProps {\\n  token: Keys;\\n}\\n\\nconst Translation: React.FC<TranslationProps> = ({ token }) => {\\n  return <TranslationBase>{(t) => t(token as unknown as any)}</TranslationBase>;\\n};\\n\\nexport default Translation;\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"使用如下：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"const orderOptions = [\\n  {\\n    label: <Translation token=\\\"global.common.updateTime\\\" />,\\n    value: 'modify_time',\\n  },\\n  {\\n    label: <Translation token=\\\"global.common.createTime\\\" />,\\n    value: 'create_time',\\n  },\\n];\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"结合模板使用Tran组件\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"<Trans i18nKey=\\\"global.template.remove_confirm\\\">\\n  {{ target: t('applications.title') }}\\n  {{ name: card.k8sName }}\\n</Trans>\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"结合\", _jsx(_components.code, {\n        children: \"google翻译\"\n      }), \"实现自动化翻译脚本\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"由于一些复杂的翻译需要用到翻译软件辅助，但翻译过后仍需人工调整，一些词性差异和专有名词翻译软件并不能完全准确翻译，因此最适合的自动化方法是编写一个脚本将未翻译的字段翻译并填写到对应文件中，再进行人工修正\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"安装\", _jsx(_components.code, {\n        children: \"@vitalets/google-translate-api\"\n      }), \"插件，通过插件来调用google翻译的API\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"import { translate } from '@vitalets/google-translate-api';\\nimport fs from 'fs';\\nimport { HttpProxyAgent } from 'http-proxy-agent';\\nimport zhText from '../locales/zh/translation.json' assert  { type: \\\"json\\\" };\\nimport enText from '../locales/en/translation.json' assert  { type: \\\"json\\\" };\\nimport { get } from 'lodash-es';\\nimport { set } from 'lodash-es';\\nimport path from 'path';\\n\\nconst enFilePath = path.resolve('./src/locales/en/translation.json');\\n\\nconst args = process.argv.slice(2);\\nconst proxy = args[0]?.match(/(?<=proxy=).*/)[0] || 'http://127.0.0.1:7890';\\nconst timeoutMs = 5000;\\n\\nasync function translateText(sourceText, to) {\\n  const ac = new AbortController();\\n  const timer = setTimeout(() => ac.abort(), timeoutMs);\\n  const fetchOptions = {\\n    agent: new HttpProxyAgent(proxy),\\n    signal: ac.signal,\\n  };\\n  try {\\n    const { text } = await translate(sourceText, { fetchOptions, to, });\\n    return text\\n  } finally {\\n    clearTimeout(timer);\\n  }\\n}\\n\\nasync function traverseTexts(translations, key = '') {\\n  for (const k in translations) {\\n    const value = translations[k]\\n    const fullKey = `${key ? `${key}.` : ''}${k}`\\n    if (typeof value === 'string') {\\n      // 只翻译新增的配置\\n      if (get(enText, fullKey) !== void 0) {\\n        continue\\n      }\\n      console.log('translating:', value)\\n      const translated = await translateText(value, 'en')\\n      set(enText, fullKey, translated)\\n    } else {\\n      await traverseTexts(value, fullKey)\\n    }\\n  }\\n}\\n\\nfunction saveEnTexts() {\\n  const jsonContent = JSON.stringify(enText, null, 2);\\n  fs.writeFileSync(enFilePath, jsonContent, 'utf8');\\n  console.log('Translation completed and saved to locales/en/translation.json');\\n}\\n\\nawait traverseTexts(zhText)\\nsaveEnTexts()\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在\", _jsx(_components.code, {\n        children: \"package.json\"\n      }), \"中添加script\", _jsx(_components.code, {\n        children: \"\\\"auto-translate\\\": \\\"node ./src/locales/translate.js\\\"\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在批量新增中文文本之后，执行\", _jsx(_components.code, {\n        children: \"npm run auto-translate\"\n      }), \"即可自动填补缺漏的英文配置，可通过\", _jsx(_components.code, {\n        children: \"--proxy=\"\n      }), \"来指定本地代理地址。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"使用react-i18next进行国际化配置","description":"在react的应用中如何进行国际化配置，并适配多种使用场景以及开发体验的提升","public":true,"date":"2024-07-25 19:03:00","category":"framework"}},"frontMatter":{"title":"使用react-i18next进行国际化配置","description":"在react的应用中如何进行国际化配置，并适配多种使用场景以及开发体验的提升","public":true,"date":"2024-07-25 19:03:00","category":"framework"},"headings":[{"depth":2,"text":"基础使用"},{"depth":2,"text":"Typescript配置实现提示"},{"depth":2,"text":"在多种场景下的使用方式"},{"depth":2,"text":"结合实现自动化翻译脚本"}]},"__N_SSG":true}